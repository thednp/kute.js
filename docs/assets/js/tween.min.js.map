{"version":3,"file":"tween.min.js","names":[],"sources":["../src/Util.ts","../src/Now.ts","../src/Runtime.ts","../src/Tween.ts","../src/Timeline.ts","../src/Easing.ts","../package.json","../src/extend/array.ts","../src/extend/path.ts","../src/extend/object.ts","../src/extend/transform.ts"],"sourcesContent":["import type { DeepObject, DeepPartial, TweenProps } from \"./types.d.ts\";\nimport { type Tween } from \"./Tween.ts\";\nimport { type Timeline } from \"./Timeline.ts\";\n\n// Util.ts\nexport const isString = (value: unknown): value is string =>\n  typeof value === \"string\";\n\nexport const isNumber = (value: unknown): value is number =>\n  typeof value === \"number\";\n\nexport const isArray = (value: unknown): value is Array<unknown> =>\n  Array.isArray(value);\n\nexport const isFunction = (value: unknown): value is () => unknown =>\n  typeof value === \"function\";\n\nexport const isObject = (\n  value: unknown,\n): value is Record<string, never> =>\n  value !== null && value !== undefined && typeof value === \"object\" &&\n  Object.getPrototypeOf(value) === Object.prototype;\n\nexport const isPlainObject = (\n  value: unknown,\n): value is Record<string, never> => isObject(value) && !isArray(value);\n\nexport const isDeepObject = (value: unknown): value is DeepObject =>\n  isPlainObject(value) && Object.values(value).some(isPlainObject);\n\n/**\n * A small utility to deep assign up to one level deep nested objects.\n * This is to prevent breaking reactivity of object properties in stores like Solid and similar.\n * This doesn't perform ANY check and expects objects to be validated beforehand.\n * @param target The target SingleNestedObject to update\n * @param source The source SingleNestedObject to update from\n */\nexport function deepMerge<T extends TweenProps>(\n  target: T,\n  source: T,\n) {\n  const keys = Object.keys(source) as (keyof T)[];\n  let i = 0;\n  const len = keys.length;\n\n  while (i < len) {\n    const key = keys[i++];\n    const sourceVal = source[key] as T[keyof T];\n    // validators should cover this\n    // if (!(key in target)) {\n    //   // console.warn(\"Property doesn't exist in target!\")\n    //   continue;\n    // }\n    \n    if (typeof sourceVal === \"object\" /*&& !Array.isArray(sourceVal)*/) { // BaseTweenProps = Record<string, number>\n      // this shouldn't be possible, objects are validated right?\n      // if (!target[key]) target[key] = {};\n      Object.assign(target[key], sourceVal);\n    // } else if (Array.isArray(sourceVal)) { // number, TransformArray | PathArray, Array<number>\n    //   // target[key].length = 0;\n    //   target[key].splice(0, sourceVal.length, ...sourceVal)\n    } else { // number, TransformArray | PathArray, Array<number>\n      target[key] = sourceVal;\n    }\n  }\n}\n\n/**\n * Test values validity or their compatibility with the validated ones\n * in the state. This is something we don't want to do in the runtime\n * update loop.\n * @param this The Tween/Timeline instance\n * @param target The target object to validate\n * @param reference The reference state value\n * @returns void\n */\nexport function validateValues<T extends TweenProps>(\n  this: Timeline | Tween,\n  target: Partial<T> | DeepPartial<T>,\n  reference?: T,\n) {  \n  const errors = this.getErrors();\n\n  if (!isPlainObject(target) || Object.keys(target).length === 0) {\n    errors.set(\"init\", \"Initialization value is empty or not an object.\");\n    return;\n  }\n  \n  const keys = Object.keys(target);\n\n  // skip if from()/to() was used before one another\n  // we don't want to validate props invalidated!\n  if (reference && keys.some((key) => errors.has(key))) {\n    return;\n  }\n\n  // Validate every value\n  let i = 0;\n  while (i < keys.length) {\n    const key = keys[i++];\n    const refValue = reference?.[key];\n    const value = target[key];\n       \n    // everything else is either number or not supported\n    if (isNumber(value)) {\n      // no error there\n      // this.removeError(key);\n      continue; // good value\n    }\n\n    if (value === undefined || value === null) {\n      errors.set(key, `Property \"${key}\" is null/undefined.`);\n      continue;\n    }\n\n    if (reference && refValue === undefined) {\n      errors.set(key, `Property \"${key}\" doesn't exist in state yet.`);\n      continue;\n    }\n\n    // allow validators to override default validation behavior\n    const validator = this.getValidator(key);\n    if (validator) {\n      const [valid, reason] = validator(key, value, refValue as never);\n      if (valid) errors.delete(key);\n      else errors.set(key, reason as string);\n      continue;\n    }\n\n    if (reference && isNumber(refValue)) {\n      // istanbul ignore else @preserve\n      if (!isNumber(value)) {\n        errors.set(key, `Property \"${key}\" is not a number.`);\n      }\n      // only validators can revalidate\n      // this case can never be covered\n      // else this.removeError(key);\n\n      continue;\n    }\n\n    // Any value here is either not valid or not supported yet\n    errors.set(\n      key,\n      `Property \"${key}\" of type \"${isArray(value) ? \"array\" : typeof value}\" is not supported yet.`,\n    );\n  }\n  errors.delete(\"init\");\n}\n","let _nowFunc = () => globalThis.performance.now();\n\nexport const now = (): number => {\n  return _nowFunc();\n};\n\nexport function setNow(nowFunction: typeof _nowFunc) {\n  _nowFunc = nowFunction;\n}\n","// Runtime.ts\nimport type { Tween } from \"./Tween.ts\";\nimport type { Timeline } from \"./Timeline.ts\";\nimport type { TweenProps } from \"./types.d.ts\";\nimport { now } from \"./Now.ts\";\n\ntype AnimationItem<T extends TweenProps = never> = Tween<T> | Timeline<T>;\n\nexport const Queue: AnimationItem[] = [];\n\nlet rafID = 0;\nlet queueLength = 0;\n\nexport function Runtime(t = now()) {\n  let i = 0;\n  queueLength = Queue.length;\n  while (i < queueLength) {\n    if (Queue[i].update(t)) {\n      i += 1;\n    } else {\n      Queue.splice(i, 1);\n      queueLength -= 1;\n    }\n  }\n\n  if (queueLength === 0) {\n    cancelAnimationFrame(rafID);\n    rafID = 0;\n  } else rafID = requestAnimationFrame(Runtime);\n}\n\nexport function addToQueue<T extends TweenProps>(\n  newItem: AnimationItem<T>,\n): void {\n  const item = newItem as unknown as AnimationItem<never>;\n  // if (!Queue.includes(item)) {\n  Queue.push(item);\n  // }\n  if (!rafID) Runtime();\n}\n\nexport function removeFromQueue<T extends TweenProps>(\n  removedItem: AnimationItem<T>,\n): void {\n  Queue.splice(\n    Queue.indexOf(removedItem as unknown as AnimationItem<never>),\n    1,\n  );\n  queueLength--;\n}\n","// Tween.ts\nimport type {\n  DeepPartial,\n  EasingFunction,\n  InterpolatorFunction,\n  PropConfig,\n  TweenCallback,\n  TweenProps,\n  TweenUpdateCallback,\n  ValidationFunction,\n} from \"./types.d.ts\";\nimport { isArray, isObject, validateValues } from \"./Util.ts\";\nimport { addToQueue, removeFromQueue } from \"./Runtime.ts\";\nimport { now } from \"./Now.ts\";\n\n/**\n * Lightweight tween engine for interpolating values over time.\n * Supports numbers and via extensions it enxtends to arrays\n * (e.g. RGB, points), nested objects, and SVG path morphing.\n *\n * @template T - The type of the target object (usually a plain object with numeric properties)\n *\n * @example\n * ```ts\n * const tween = new Tween({ x: 0, opacity: 1 })\n *   .to({ x: 300, opacity: 0 })\n *   .duration(1.5)\n *   .easing(Easing.Elastic.Out)\n *   .start();\n * ```\n *\n * @param initialValues The initial values object\n */\nexport class Tween<T extends TweenProps = TweenProps> {\n  state: T;\n  private _state: T;\n  private _startIsSet = false;\n  private _repeat = 0;\n  private _yoyo = false;\n  private _reversed = false;\n  private _initialRepeat = 0;\n  private _startFired = false;\n  private _propsStart: Partial<T> = {};\n  private _propsEnd: Partial<T> = {};\n  private _isPlaying = false;\n  private _duration = 1000;\n  private _delay = 0;\n  private _startTime: number = 0;\n  private _errors = new Map<string | \"init\", string>();\n  private _interpolators = new Map<string, InterpolatorFunction>();\n  private _validators = new Map<string, ValidationFunction>();\n  private _easing: EasingFunction = (t) => t;\n  private _onUpdate?: TweenUpdateCallback<T>;\n  private _onComplete?: TweenCallback<T>;\n  private _onStart?: TweenCallback<T>;\n  private _onStop?: TweenCallback<T>;\n  private _runtime: [\n    targetObject: T[keyof T],\n    property: string,\n    interpolator: InterpolatorFunction | null,\n    startVal: T[keyof T],\n    endVal: T[keyof T],\n  ][] = [];\n  /**\n   * Creates a new Tween instance.\n   * @param initialValues - The initial state of the animated object\n   */\n  constructor(initialValues: T) {\n    // we must initialize state to allow isValidState to work from here\n    this.state = {} as T;\n    validateValues.call(this as unknown as Tween, initialValues);\n    if (this._errors.size) {\n      // we temporarily store initialValues reference here\n      this._state = initialValues;\n    } else {\n      // or set values right away\n      this.state = initialValues;\n      this._state = { ...initialValues };\n    }\n\n    return this;\n  }\n\n  // GETTERS FIRST\n  /**\n   * A boolean that returns `true` when tween is playing.\n   */\n  get isPlaying(): boolean {\n    return this._isPlaying;\n  }\n\n  /**\n   * A boolean that returns `true` when initial values are valid.\n   */\n  get isValidState(): boolean {\n    return Object.keys(this.state).length > 0;\n  }\n\n  /**\n   * A boolean that returns `true` when all values are valid.\n   */\n  get isValid(): boolean {\n    return this._errors.size === 0;\n  }\n\n  /**\n   * Returns the configured duration in seconds.\n   */\n  getDuration() {\n    return this._duration / 1000;\n  }\n\n  /**\n   * Returns the validator configured for a given property.\n   */\n  getValidator(propName: string) {\n    return this._validators.get(propName);\n  }\n\n  /**\n   * Returns the errors Map, mainly used by external validators.\n   */\n  getErrors() {\n    return this._errors;\n  }\n\n  /**\n   * Starts the tween (adds it to the global update loop).\n   * Triggers `onStart` if set.\n   * @param time - Optional explicit start time (defaults to `now()`)\n   * @param overrideStart - If true, resets starting values even if already set\n   * @returns this\n   */\n  start(time = now(), overrideStart = false) {\n    if (this._isPlaying) return this;\n    if (!this.isValid) {\n      this._report();\n      return this;\n    }\n    // istanbul ignore else @preserve\n    if (!this._startIsSet || /* istanbul ignore next */ overrideStart) {\n      this._startIsSet = true;\n\n      this._setProps(\n        this.state,\n        this._propsStart,\n        this._propsEnd,\n        overrideStart,\n      );\n    }\n    this._isPlaying = true;\n    this._startTime = time;\n    this._startTime += this._delay;\n    addToQueue(this);\n    return this;\n  }\n\n  /**\n   * Starts the tween from current values.\n   * @param time - Optional explicit start time (defaults to `now()`)\n   * @returns this\n   */\n  startFromLast(time = now()) {\n    return this.start(time, true);\n  }\n\n  /**\n   * Immediately stops the tween and removes it from the update loop.\n   * Triggers `onStop` if set.\n   * @returns this\n   */\n  stop() {\n    if (!this._isPlaying) return this;\n    removeFromQueue(this);\n    this._isPlaying = false;\n    this._onStop?.(this.state);\n    return this;\n  }\n\n  /**\n   * Sets the starting values for properties.\n   * @param startValues - Partial object with starting values\n   * @returns this\n   */\n  from(startValues: Partial<T> | DeepPartial<T>) {\n    if (!this.isValidState || this.isPlaying) return this;\n\n    this._evaluate(startValues);\n    if (this.isValid) {\n      Object.assign(this._propsStart, startValues);\n      this._startIsSet = false;\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the ending values for properties.\n   * @param endValues - Partial object with target values\n   * @returns this\n   */\n  to(endValues: Partial<T> | DeepPartial<T>) {\n    if (!this.isValidState || this.isPlaying) return this;\n\n    this._evaluate(endValues);\n    if (this.isValid) {\n      this._propsEnd = endValues as T;\n      this._startIsSet = false;\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the duration of the tween in seconds.\n   * Internally it's converted to milliseconds.\n   * @param duration - Time in seconds\n   * @default 1\n   * @returns this\n   */\n  duration(seconds = 1) {\n    this._duration = seconds * 1000;\n    return this;\n  }\n\n  /**\n   * Sets the delay in seconds before the tween starts.\n   * Internally it's converted to milliseconds.\n   * @param delay - Time in seconds\n   * @default 0\n   * @returns this\n   */\n  delay(seconds = 0) {\n    this._delay = seconds * 1000;\n    return this;\n  }\n\n  /**\n   * Sets how many times to repeat.\n   * @param times - How many times to repeat\n   * @default 0\n   * @returns this\n   */\n  repeat(times = 0) {\n    this._repeat = times;\n    this._initialRepeat = times;\n    return this;\n  }\n\n  /**\n   * Sets to tween from end to start values.\n   * This requires repeat value of at least 1.\n   * @param yoyo - How many times to repeat\n   * @default false\n   * @returns this\n   */\n  yoyo(yoyo = false) {\n    this._yoyo = yoyo;\n    return this;\n  }\n\n  /**\n   * Sets the easing function.\n   * @param easing - Function that maps progress [0,1] → eased progress [0,1]\n   * @default linear\n   * @returns this\n   */\n  easing(easing: EasingFunction = (t: number) => t) {\n    this._easing = easing;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.start()` is called.\n   * @param callback - Receives state at start time\n   * @returns this\n   */\n  onStart(callback: TweenCallback<T>) {\n    this._onStart = callback;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired on every frame.\n   * @param callback - Receives current state, elapsed (0–1)\n   * @returns this\n   */\n  onUpdate(callback?: TweenUpdateCallback<T>) {\n    this._onUpdate = callback;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when the tween reaches progress = 1.\n   * @param callback - Receives final state\n   * @returns this\n   */\n  onComplete(callback: TweenCallback<T>) {\n    this._onComplete = callback;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.stop()` is called.\n   * @param callback - Receives state at stop time\n   * @returns this\n   */\n  onStop(callback: TweenCallback<T>) {\n    this._onStop = callback;\n    return this;\n  }\n\n  /**\n   * Manually advances the tween to the given time.\n   * @param time - Current absolute time (performance.now style)\n   * @param autoStart - If true, starts the tween if not already playing\n   * as well.\n   *\n   * **Note** - if you `stop()` the tween, but are still calling\n   * `update()`, it will start again!\n   *\n   * @returns `true` if the tween is still playing after the update, `false`\n   * otherwise.\n   */\n  update(time = now(), autoStart?: boolean) {\n    // istanbul ignore else\n    if (!this._isPlaying) {\n      // istanbul ignore else\n      if (autoStart) this.start(time, true);\n      else return false;\n    }\n\n    // istanbul ignore else\n    if (time < this._startTime) return true;\n\n    // istanbul ignore else\n    if (!this._startFired && this._onStart) {\n      this._onStart(this.state);\n      this._startFired = true;\n    }\n\n    let elapsed = (time - this._startTime) / this._duration;\n    elapsed = elapsed > 1 ? /* istanbul ignore next */ 1 : elapsed;\n    let progress = this._easing(elapsed);\n    // super cheap yoyo\n    progress = this._reversed ? 1 - progress : progress;\n\n    let i = 0;\n    const runtime = this._runtime;\n    const state = this.state;\n    let len = runtime.length;\n    while (i < len) {\n      const [targetObject, property, interpolator, startVal, endVal] =\n      runtime[i++];\n      // istanbul ignore else @preserve\n      if (typeof endVal === \"number\") {\n        state[property as keyof T] = ((startVal as number) +\n          (endVal - (startVal as number)) * progress) as T[keyof T];\n      } else if (interpolator) {\n        interpolator(\n          targetObject as never,\n          startVal as never,\n          endVal as never,\n          progress,\n        );\n      }\n    }\n\n    this._onUpdate?.(this.state, elapsed);\n\n    // istanbul ignore else\n    if (elapsed === 1) {\n      if (this._repeat === 0) {\n        this._isPlaying = false;\n        this._repeat = this._initialRepeat;\n        this._reversed = false;\n        this._onComplete?.(this.state);\n        return false;\n      } else {\n        // istanbul ignore else @preserve\n        if (this._repeat !== Infinity) this._repeat--;\n        if (this._yoyo) this._reversed = !this._reversed;\n        this._startTime = time;\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Public method to register an extension for a given property.\n   *\n   * **NOTES**\n   * - the extension will validate the initial values once `.use()` is called.\n   * - the `.use()` method must be called before `.to()` / `.from()`.\n   *\n   * @param property The property name\n   * @param extension The extension object\n   * @returns this\n   *\n   * @example\n   *\n   * const tween = new Tween({ myProp: { x: 0, y: 0 } });\n   * tween.use(\"myProp\", objectConfig);\n   */\n  use(property: string, { interpolate, validate }: PropConfig): this {\n    // istanbul ignore else\n    if (interpolate && !this._interpolators.has(property)) {\n      this._interpolators.set(property, interpolate);\n    }\n    if (validate && !this._validators.has(property)) {\n      this._validators.set(property, validate);\n    }\n    this._evaluate();\n    return this;\n  }\n\n  /**\n   * Internal method to handle instrumentation of start and end values for interpolation.\n   * @internal\n   */\n  private _setProps(\n    obj: T,\n    propsStart: Partial<T>,\n    propsEnd: Partial<T>,\n    overrideStartingValues: boolean,\n  ): void {\n    this._runtime.length = 0;\n    const endKeys = Object.keys(propsEnd);\n    const len = endKeys.length;\n    let i = 0;\n\n    while (i < len) {\n      const property = endKeys[i++];\n\n      // Save the starting value, but only once unless override is requested.\n      // istanbul ignore else\n      if (\n        typeof propsStart[property] === \"undefined\" ||\n        overrideStartingValues\n      ) {\n        const objValue = obj[property];\n        const clone = isObject(objValue)\n          ? {...objValue}\n          : isArray(objValue) ? objValue.slice(0)\n          : objValue;\n\n        // Update start property value\n        propsStart[property as keyof T] = clone as T[keyof T];\n\n        // Pre-register interpolator\n        const interpolator = this._interpolators.get(property) || null;\n        // Store all values needed for interpolation\n        this._runtime.push([\n          obj[property] as T[keyof T],\n          property,\n          interpolator,\n          clone as T[keyof T],\n          propsEnd[property] as T[keyof T],\n        ]);\n      }\n    }\n  }\n\n  /**\n   * Internal method to handle validation of initial values, start and end values.\n   * @internal\n   */\n  private _evaluate(newObj?: Partial<T> | DeepPartial<T>) {\n    // the reference of the initialization state is stored here\n    // istanbul ignore else @preserve\n    if (!this.isValidState) {\n      const temp = this._state;\n      validateValues.call(this as unknown as Tween, temp);\n      // istanbul ignore else @preserve\n      if (this.isValid) {\n        this.state = temp;\n        this._state = { ...temp };\n      }\n    } else if (newObj) {\n      validateValues.call(this as unknown as Tween, newObj, this._state);\n    }\n    return this;\n  }\n\n  /**\n   * Internal method to provide feedback on validation issues.\n   * @internal\n   */\n  private _report() {\n    // istanbul ignore else @preserve\n    if (!this.isValid) {\n      const message = [\n        \"[Tween] failed validation:\",\n        \"- \" + Array.from(this._errors.values()).join(\"\\n- \"),\n      ];\n\n      console.warn(message.join(\"\\n\"));\n    }\n    return this;\n  }\n}\n","// Timeline.ts\nimport type {\n  BaseTweenProps,\n  DeepPartial,\n  InterpolatorFunction,\n  Position,\n  PropConfig,\n  TimelineCallback,\n  TimelineEntry,\n  TimelineEntryConfig,\n  TweenProps,\n  ValidationFunction,\n} from \"./types.d.ts\";\nimport { addToQueue, removeFromQueue } from \"./Runtime.ts\";\nimport { isArray, isObject, validateValues } from \"./Util.ts\";\nimport { now } from \"./Now.ts\";\n\n/**\n * Timeline orchestrates multiple tweens with scheduling, overlaps, labels and repeat.\n * Supports numbers and via extensions it enxtends to arrays\n * (e.g. RGB, points), nested objects, and SVG path morphing.\n *\n * @template T - Type of the animated state object\n *\n * @example\n * ```ts\n * const tl = new Timeline({ x: 0, opacity: 0 })\n *   .to({ x: 300, duration: 1.2 })\n *   .to({ opacity: 1, duration: 0.8 }, \"-=0.4\")\n *   .play();\n * ```\n *\n * @param initialValues The initial values object\n */\nexport class Timeline<T extends TweenProps = TweenProps> {\n  public state: T;\n  private _state: T;\n  private _entries: TimelineEntry<T>[] = [];\n  private _labels = new Map<string, number>();\n  private _progress = 0;\n  private _duration = 0;\n  private _time = 0;\n  private _pauseTime = 0;\n  private _lastTime?: number;\n  private _isPlaying = false;\n  private _repeat = 0;\n  private _initialRepeat = 0;\n  private _errors = new Map<string | \"init\", string>();\n  private _interpolators = new Map<string | keyof T, InterpolatorFunction>();\n  private _validators = new Map<string | keyof T, ValidationFunction>();\n  private _onStart?: TimelineCallback<T>;\n  private _onStop?: TimelineCallback<T>;\n  private _onPause?: TimelineCallback<T>;\n  private _onResume?: TimelineCallback<T>;\n  private _onUpdate?: TimelineCallback<T>;\n  private _onComplete?: TimelineCallback<T>;\n\n  /**\n   * Creates a new Timeline instance.\n   * @param initialValues - The initial state of the animated object\n   */\n  constructor(initialValues: T) {\n    // we must initialize state to allow isValidState to work from here\n    this.state = {} as T;\n    validateValues.call(this as Timeline, initialValues);\n    if (this._errors.size) {\n      // we temporarily store initialValues reference here\n      this._state = initialValues;\n    } else {\n      this.state = initialValues;\n      this._state = { ...initialValues };\n    }\n\n    return this;\n  }\n\n  // GETTERS FIRST\n  /**\n   * Returns the current [0-1] progress value.\n   */\n  get progress(): number {\n    return this._progress;\n  }\n\n  /**\n   * Returns the total duration in seconds.\n   */\n  get duration(): number {\n    return this._duration / 1000;\n  }\n\n  /**\n   * Returns the total duration in seconds, multiplied by repeat value.\n   */\n  get totalDuration(): number {\n    return (this._duration * (this._initialRepeat || 1)) / 1000;\n  }\n\n  /**\n   * A boolean that returns `true` when timeline is playing.\n   */\n  get isPlaying(): boolean {\n    return this._isPlaying;\n  }\n\n  /**\n   * A boolean that returns `true` when timeline is paused.\n   */\n  get isPaused(): boolean {\n    return !this._isPlaying && this._pauseTime > 0;\n  }\n\n  /**\n   * A boolean that returns `true` when initial values are valid.\n   */\n  get isValidState(): boolean {\n    return Object.keys(this.state).length > 0;\n  }\n\n  /**\n   * A boolean that returns `true` when all values are valid.\n   */\n  get isValid(): boolean {\n    return this._errors.size === 0;\n  }\n\n  /**\n   * Returns the validator configured for a given property.\n   */\n  getValidator(propName: string) {\n    return this._validators.get(propName);\n  }\n\n  /**\n   * Returns the errors Map, mainly used by external validators.\n   */\n  getErrors() {\n    return this._errors;\n  }\n\n  /**\n   * Starts or resumes playback from the beginning (or current time if resumed).\n   * Triggers the `onStart` callback if set.\n   * @param startTime - Optional explicit start timestamp (defaults to now)\n   * @returns this\n   */\n  play(): this {\n    if (this._pauseTime) return this.resume();\n    if (this._isPlaying) return this;\n    if (!this.isValid) {\n      this._report();\n      return this;\n    }\n\n    this._isPlaying = true;\n    this._lastTime = undefined;\n    this._time = 0;\n    this._resetState();\n    this._updateEntries(0);\n    this._onStart?.(this.state, 0);\n\n    addToQueue(this);\n    return this;\n  }\n\n  /**\n   * Pauses playback (preserves current time).\n   * Triggers the `onPause` callback if set.\n   * @returns this\n   */\n  pause(): this {\n    if (!this._isPlaying) return this;\n    this._isPlaying = false;\n    this._pauseTime = now();\n    this._onPause?.(this.state, this.progress);\n    return this;\n  }\n\n  /**\n   * Resumes from paused state (adjusts internal clock).\n   * Triggers the `onResume` callback if set.\n\n   * @param time - Optional current timestamp (defaults to now)\n   * @returns this\n   */\n  resume(time = now()): this {\n    if (this._isPlaying) return this;\n    this._isPlaying = true;\n    const dif = time - this._pauseTime;\n    this._pauseTime = 0;\n    this._lastTime = (this._lastTime || time) + dif;\n    this._onResume?.(this.state, this.progress);\n\n    addToQueue(this);\n    return this;\n  }\n\n  /**\n   * Stops playback, resets time to 0, and restores initial state.\n   * Triggers the `onStop` callback if set.\n   * @param completed - If true, indicates natural completion (affects callbacks)\n   * @returns this\n   */\n  stop(): this {\n    if (!this._isPlaying) return this;\n    this._isPlaying = false;\n    this._time = 0;\n    this._pauseTime = 0;\n    removeFromQueue(this);\n    this._resetState();\n    this._updateEntries(0);\n    this._onStop?.(this.state, this._progress);\n    return this;\n  }\n\n  /**\n   * Sets the number of times the timeline should repeat.\n   * @param count - Number of repeats (0 = once, Infinity = loop forever)\n   * @returns this\n   */\n  repeat(count = 0): this {\n    this._repeat = count;\n    this._initialRepeat = count;\n    return this;\n  }\n\n  /**\n   * Jumps to a specific time or label.\n   * @param pointer - Seconds or label name\n   * @returns this\n   */\n  seek(pointer: number | string): this {\n    const elapsed = this._resolvePosition(pointer);\n    this._resetState();\n    this._time = Math.max(0, elapsed);\n    this._updateEntries(this._time);\n    return this;\n  }\n\n  /**\n   * Adds a named time position for use in `.seek(\"label\")`.\n   * @param name - Label identifier\n   * @param position - Time offset or relative position\n   * @returns this\n   */\n  label(name: string, position?: Position): this {\n    this._labels.set(name, this._resolvePosition(position));\n    return this;\n  }\n\n  /**\n   * Adds a new tween entry to the timeline.\n   * @param config - Values to animate + duration, easing, etc.\n   * @param position - Start offset: number, \"+=0.5\", \"-=0.3\", or label name\n   * @returns this (chainable)\n   */\n  to(\n    {\n      duration = 1,\n      easing = (t) => t,\n      ...values\n    }: (Partial<T> | DeepPartial<T>) & TimelineEntryConfig,\n    position: Position = \"+=0\",\n  ): this {\n    if (!this.isValidState) return this;\n\n    this._evaluate(values as Partial<T> | DeepPartial<T>);\n    if (this.isValid) {\n      const startTime = this._resolvePosition(position);\n      const to = values as Partial<T> | DeepPartial<T>;\n      const entryDuration = duration * 1000;\n      const runtime = [] as TimelineEntry<T>[\"runtime\"];\n\n      this._entries.push({\n        from: {},\n        to,\n        runtime,\n        startTime,\n        duration: entryDuration,\n        easing,\n        hasStarted: false,\n      });\n\n      const endTime = startTime + entryDuration;\n      this._duration = Math.max(this._duration, endTime);\n    }\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when playback begins.\n   */\n  onStart(cb: TimelineCallback<T>): this {\n    this._onStart = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `pause()` was called.\n   */\n  onPause(cb: TimelineCallback<T>): this {\n    this._onPause = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.play()` / `.resume()` was called.\n   */\n  onResume(cb: TimelineCallback<T>): this {\n    this._onResume = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired on explicit `.stop()`.\n   */\n  onStop(cb: TimelineCallback<T>): this {\n    this._onStop = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired every frame.\n   */\n  onUpdate(cb: TimelineCallback<T>): this {\n    this._onUpdate = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when timeline naturally completes.\n   */\n  onComplete(cb: TimelineCallback<T>): this {\n    this._onComplete = cb;\n    return this;\n  }\n\n  update(time = now()) {\n    if (!this._isPlaying) return false;\n    if (this._lastTime === undefined) this._lastTime = time;\n    const delta = time - this._lastTime;\n    this._lastTime = time;\n    this._time += delta;\n\n    this._updateEntries(this._time);\n\n    // istanbul ignore else\n    if (this._progress === 1) {\n      // istanbul ignore else\n      if (this._repeat === 0) {\n        this._isPlaying = false;\n        this._repeat = this._initialRepeat;\n        this._onComplete?.(this.state, 1);\n      } else {\n        // istanbul ignore else @preserve\n        if (this._repeat !== Infinity) this._repeat--;\n        this._time = 0;\n        this._resetState();\n        this._updateEntries(0);\n      }\n    }\n    return this._isPlaying;\n  }\n\n  /**\n   * Internal method to interpolate values of all tween entries.\n   * @internal\n   */\n  private _updateEntries(elapsed: number) {\n    this._progress =\n      this._duration === 0 || elapsed >= this._duration\n        ? 1\n        : elapsed / this._duration;\n\n    let i = 0;\n    const entries = this._entries;\n    const state = this.state;\n    const entriesLen = entries.length;\n    while (i < entriesLen) {\n      const entry = entries[i++];\n      const localTime = elapsed - entry.startTime;\n      const tweenElapsed = Math.max(0, Math.min(1, localTime / entry.duration));\n\n      if (!entry.hasStarted && tweenElapsed > 0) {\n        this._setEntry(entry);\n      }\n\n      // istanbul ignore else @preserve\n      if (entry.hasStarted) {\n        const easedValue = entry.easing(tweenElapsed);\n        const runtimeLen = entry.runtime.length;\n        let j = 0;\n\n        while (j < runtimeLen) {\n          const [targetObject, property, interpolator, startVal, endVal] = entry.runtime[j++];\n          // istanbul ignore else @preserve\n          if (typeof endVal === \"number\") {\n            state[property as keyof T] = ((startVal as number) +\n              (endVal - (startVal as number)) * easedValue) as T[keyof T];\n          } else if (interpolator) {\n            interpolator(\n              targetObject as never,\n              startVal as never,\n              endVal as never,\n              easedValue,\n            );\n          }\n        }\n      }\n    }\n\n    if (this._onUpdate) {\n      this._onUpdate(this.state, this._progress);\n    }\n  }\n\n  /**\n   * Internal method to resolve the position relative to the current duration\n   * or a set value in seconds.\n   * @internal\n   */\n  private _resolvePosition(pos?: Position): number {\n    if (typeof pos === \"number\") return pos * 1000;\n\n    // istanbul ignore else @preserve\n    if (typeof pos === \"string\") {\n      // First try label\n      const labelTime = this._labels.get(pos);\n      if (labelTime !== undefined) return labelTime;\n\n      // Then relative\n      // istanbul ignore else @preserve\n      if (pos.startsWith(\"+=\") || pos.startsWith(\"-=\")) {\n        let offset = parseFloat(pos.slice(2));\n        if (isNaN(offset)) offset = 0;\n        offset *= 1000;\n        return pos.startsWith(\"+=\")\n          ? this._duration + offset\n          : Math.max(0, this._duration - offset);\n      }\n    }\n\n    // fallback to current duration\n    return this._duration;\n  }\n\n  /**\n   * Internal method to handle instrumentation of start and end values for interpolation\n   * of a tween entry.\n   * @internal\n   */\n  private _setEntry(entry: TimelineEntry<T>) {\n    entry.hasStarted = true;\n    entry.from = {};\n    entry.runtime.length = 0;\n    const keysTo = Object.keys(entry.to) as (keyof T)[];\n    const keyLen = keysTo.length;\n    const state = this.state;\n    let j = 0;\n\n    while (j < keyLen) {\n      const key = keysTo[j++];\n      const objValue = state[key];\n      const clone = isObject(objValue)\n        ? {...objValue as BaseTweenProps} \n        : isArray(objValue) ? objValue.slice(0)\n        : objValue;\n\n      entry.from[key] = clone as T[keyof T];\n      // Pre-register interpolator\n      const interpolator = this._interpolators.get(key) || null;\n      // Store all data needed for interpolation\n      entry.runtime.push([\n        state[key],\n        key,\n        interpolator,\n        clone as T[keyof T],\n        entry.to[key] as unknown as T[keyof T],\n      ]);\n    }\n  }\n\n  /**\n   * Internal method to revert state to initial values.\n   * @internal\n   */\n  private _resetState() {\n    Object.assign(this.state, this._state);\n    let i = 0;\n    const entriesLen = this._entries.length;\n    while (i < entriesLen) {\n      const entry = this._entries[i];\n      entry.hasStarted = false;\n      entry.from = undefined;\n      entry.runtime.length = 0;\n      i += 1;\n    }\n  }\n\n  /**\n   * Public method to clear all entries, labels and reset timers to zero\n   * or initial value (repeat).\n   */\n  clear() {\n    this._entries.length = 0;\n    this._duration = 0;\n    this._labels.clear();\n    this._time = 0;\n    this._progress = 0;\n    this._pauseTime = 0;\n    this._lastTime = undefined;\n    // Optionally reset repeat if you want fresh repeats on remount\n    this._repeat = this._initialRepeat;\n    return this;\n  }\n\n  /**\n   * Public method to register an extension for a given property.\n   *\n   * **NOTES**\n   * - the extension will validate the initial values once `.use()` is called.\n   * - the `.use()` method must be called before `.to()`.\n   *\n   * @param property The property name\n   * @param extension The extension object\n   * @returns this\n   *\n   * @example\n   *\n   * const timeline = new Timeline({ myProp: { x: 0, y: 0 } });\n   * timeline.use(\"myProp\", objectConfig);\n   */\n  use(property: string, { interpolate, validate }: PropConfig): this {\n    // istanbul ignore else\n    if (interpolate && !this._interpolators.has(property)) {\n      this._interpolators.set(property, interpolate);\n    }\n    if (validate && !this._validators.has(property)) {\n      this._validators.set(property, validate);\n    }\n    this._evaluate();\n    return this;\n  }\n\n  /**\n   * Internal method to handle validation of initial values, start and end values.\n   * @internal\n   */\n  private _evaluate(newObj?: Partial<T> | DeepPartial<T>) {\n    // the reference of the initialization state is stored here\n    // istanbul ignore else @preserve\n    if (!this.isValidState) {\n      const temp = this._state;\n      validateValues.call(this as Timeline, temp);\n      // istanbul ignore else @preserve\n      if (this.isValid) {\n        this.state = temp;\n        this._state = { ...temp };\n      }\n    } else if (newObj) {\n      validateValues.call(this as Timeline, newObj, this._state);\n    }\n    return this;\n  }\n\n  /**\n   * Internal method to provide feedback on validation issues.\n   * @internal\n   */\n  private _report() {\n    // istanbul ignore else @preserve\n    if (!this.isValid) {\n      const message = [\n        \"[Timeline] failed validation:\",\n        \"- \" + Array.from(this._errors.values()).join(\"\\n- \"),\n      ].join(\"\\n\");\n\n      console.warn(message);\n    }\n    return this;\n  }\n}\n","// Easing.ts\nimport type { EasingFunction, EasingFunctionGroup } from \"./types.d.ts\";\n\n/**\n * The Ease class provides a collection of easing functions for use with tween.js.\n */\n\nexport const Easing = Object.freeze({\n  Linear: Object.freeze<EasingFunctionGroup & { None: EasingFunction }>({\n    None(amount: number): number {\n      return amount;\n    },\n    In(amount: number): number {\n      return amount;\n    },\n    Out(amount: number): number {\n      return amount;\n    },\n    InOut(amount: number): number {\n      return amount;\n    },\n  }),\n\n  Quadratic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount;\n      },\n      Out(amount: number): number {\n        return amount * (2 - amount);\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount;\n        }\n\n        return -0.5 * (--amount * (amount - 2) - 1);\n      },\n    },\n  ),\n\n  Cubic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount * amount;\n      },\n      Out(amount: number): number {\n        return --amount * amount * amount + 1;\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount * amount;\n        }\n        return 0.5 * ((amount -= 2) * amount * amount + 2);\n      },\n    },\n  ),\n\n  Quartic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount * amount * amount;\n      },\n      Out(amount: number): number {\n        return 1 - --amount * amount * amount * amount;\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount * amount * amount;\n        }\n\n        return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n      },\n    },\n  ),\n\n  Quintic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount * amount * amount * amount;\n      },\n      Out(amount: number): number {\n        return --amount * amount * amount * amount * amount + 1;\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount * amount * amount * amount;\n        }\n\n        return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\n      },\n    },\n  ),\n\n  Sinusoidal: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return 1 - Math.sin(((1.0 - amount) * Math.PI) / 2);\n      },\n      Out(amount: number): number {\n        return Math.sin((amount * Math.PI) / 2);\n      },\n      InOut(amount: number): number {\n        return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));\n      },\n    },\n  ),\n\n  Exponential: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount === 0 ? 0 : Math.pow(1024, amount - 1);\n      },\n      Out(amount: number): number {\n        return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\n      },\n      InOut(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n\n        if ((amount *= 2) < 1) {\n          return 0.5 * Math.pow(1024, amount - 1);\n        }\n\n        return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\n      },\n    },\n  ),\n\n  Circular: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return 1 - Math.sqrt(1 - amount * amount);\n      },\n      Out(amount: number): number {\n        return Math.sqrt(1 - --amount * amount);\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n        }\n        return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n      },\n    },\n  ),\n\n  Elastic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n\n        return (\n          -Math.pow(2, 10 * (amount - 1)) *\n          Math.sin((amount - 1.1) * 5 * Math.PI)\n        );\n      },\n      Out(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n        return (\n          Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1\n        );\n      },\n      InOut(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n\n        amount *= 2;\n\n        if (amount < 1) {\n          return (\n            -0.5 *\n            Math.pow(2, 10 * (amount - 1)) *\n            Math.sin((amount - 1.1) * 5 * Math.PI)\n          );\n        }\n\n        return (\n          0.5 *\n            Math.pow(2, -10 * (amount - 1)) *\n            Math.sin((amount - 1.1) * 5 * Math.PI) +\n          1\n        );\n      },\n    },\n  ),\n\n  Back: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        const s = 1.70158;\n        return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);\n      },\n      Out(amount: number): number {\n        const s = 1.70158;\n        return amount === 0\n          ? 0\n          : --amount * amount * ((s + 1) * amount + s) + 1;\n      },\n      InOut(amount: number): number {\n        const s = 1.70158 * 1.525;\n        if ((amount *= 2) < 1) {\n          return 0.5 * (amount * amount * ((s + 1) * amount - s));\n        }\n        return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);\n      },\n    },\n  ),\n\n  Bounce: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return 1 - Easing.Bounce.Out(1 - amount);\n      },\n      Out(amount: number): number {\n        if (amount < 1 / 2.75) {\n          return 7.5625 * amount * amount;\n        } else if (amount < 2 / 2.75) {\n          return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n        } else if (amount < 2.5 / 2.75) {\n          return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\n        } else {\n          return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\n        }\n      },\n      InOut(amount: number): number {\n        if (amount < 0.5) {\n          return Easing.Bounce.In(amount * 2) * 0.5;\n        }\n        return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n      },\n    },\n  ),\n\n  pow(power = 4): EasingFunctionGroup {\n    power = power < Number.EPSILON ? Number.EPSILON : power;\n    power = power > 10000 ? 10000 : power;\n    return {\n      In(amount: number): number {\n        return amount ** power;\n      },\n      Out(amount: number): number {\n        return 1 - (1 - amount) ** power;\n      },\n      InOut(amount: number): number {\n        if (amount < 0.5) {\n          return (amount * 2) ** power / 2;\n        }\n        return (1 - (2 - amount * 2) ** power) / 2 + 0.5;\n      },\n    };\n  },\n});\n","","// src/extend/array.ts\nimport { isArray, isNumber } from \"../Util.ts\";\nimport { InterpolatorFunction, ValidationResultEntry } from \"../types.ts\";\n\n/**\n * Interpolates two `Array<number>` values.\n * \n * **NOTE**: Values my be validated first!\n * @param target The target `Array<number>` value\n * @param start The start `Array<number>` value\n * @param end The end `Array<number>` value\n * @param value The progress value\n * @returns The interpolated `Array<number>` value.\n */\nexport const interpolateArray: InterpolatorFunction<number[]> = <\n  T extends number[],\n>(\n  target: T,\n  start: T,\n  end: T,\n  value: number,\n) => {\n  // const result = [] as unknown as T;\n  target.length = 0;\n  const len = end.length;\n  let i = 0;\n\n  while (i < len) {\n    target.push(start[i] + (end[i] - start[i]) * value);\n    i += 1;\n  }\n  return target;\n};\n\n/**\n * Check if a value is a valid array for interpolation\n * @param target The array to check\n * @returns `true` is value is array and all elements are numbers\n */\nexport const isValidArray = <T extends number[]>(\n  target: unknown,\n): target is T => isArray(target) && target.every(isNumber);\n\n/**\n * Check if an array of numbers is compatible with a reference\n * @param target The incoming value `from()` / `to()`\n * @param ref The state reference value\n * @returns [boolean, reason] tuple when arrays are compatible or\n */\nexport const validateArray = <T extends number[]>(\n  propName: string,\n  target: unknown,\n  ref?: T,\n): ValidationResultEntry => {\n  // istanbul ignore if @preserve\n  if (!isArray(target)) return [false, `Property \"${String(propName)}\" is not Array.`];\n  // istanbul ignore if @preserve\n  if (!isValidArray(target)) return [false, `Property \"${String(propName)}\" is not a valid Array<number>.`];\n\n  if (ref && ref.length !== target.length) {\n    return [false, `Property \"${String(propName)}\" is expecting an array of ${ref.length} numbers.`];\n  }\n\n  return [true];\n};\n\n/**\n * Config for .use(propName, arrayConfig)\n */\nexport const arrayConfig = {\n  interpolate: interpolateArray,\n  validate: validateArray,\n}\n","// src/extend/path.ts\nimport { isArray, isNumber } from \"../Util.ts\";\n\nimport type {\n  CubicValues,\n  InterpolatorFunction,\n  LineValues,\n  MorphPathArray,\n  MorphPathSegment,\n  PathLike,\n  ValidationResultEntry,\n} from \"../types.ts\";\n\nconst roundTo = (n: number, round: number) => {\n  const pow = round >= 1 ? 10 ** round : 1;\n  return round > 0 ? Math.round(n * pow) / pow : Math.round(n);\n};\n\n/**\n * Iterates a `PathArray` and concatenates the values into a string to return it.\n * **NOTE**: Segment values are rounded to 4 decimals by default.\n * @param path A source PathArray\n * @param round An optional parameter to round segment values to a number of decimals\n * @returns A path string\n */\nexport function pathToString(path: MorphPathArray, round = 4) {\n  const pathLen = path.length;\n  let segment = path[0];\n  let values = segment.slice(1) as number[];\n  let result = \"\";\n  let i = 0;\n\n  while (i < pathLen) {\n    segment = path[i++];\n    result += segment[0];\n    values = segment.slice(1) as number[];\n\n    let j = 0;\n    const valLen = values.length;\n    while (j < valLen) {\n      result += roundTo(values[j], round);\n      if (j !== valLen - 1) result += \" \";\n      j += 1;\n    }\n  }\n\n  return result;\n  // return p.map(([c, ...args]) => c + args.join(\",\")).join(\" \");\n}\n\n/**\n * Interpolate PathArray values.\n * **NOTE**: these values must be validated first! Check validatePath for more info.\n * @param target - The target PathArray value\n * @param start - A starting PathArray value\n * @param end - An ending PathArray value\n * @param t - The progress value\n * @returns The interpolated PathArray value\n */\nexport const interpolatePath: InterpolatorFunction<MorphPathSegment[]> = <\n  T extends MorphPathArray,\n>(\n  target: T,\n  start: T,\n  end: T,\n  t: number,\n): T => {\n  // const result = [] as MorphPathSegment[];\n  target.length = 0;\n  const segCount = end.length;\n  let i = 0;\n\n  while (i < segCount) {\n    const [pathCommand1, values1] = [\n      start[i][0],\n      start[i].slice(1) as LineValues | CubicValues,\n    ];\n    const [pathCommand2, values2] = [\n      end[i][0],\n      end[i].slice(1) as LineValues | CubicValues,\n    ];\n\n    if (pathCommand1 === \"Z\") {\n      target.push([\"Z\"]);\n    } else {\n      const resValues = [] as unknown as CubicValues | LineValues;\n      const valsLengh = values2.length;\n      let j = 0;\n\n      while (j < valsLengh) {\n        resValues.push(values1[j] + (values2[j] - values1[j]) * t);\n        j += 1;\n      }\n      target.push([pathCommand2, ...resValues] as MorphPathSegment);\n    }\n\n    i++;\n  }\n\n  return target as T;\n};\n\nconst supportedPathCommands = [\"M\", \"L\", \"C\", \"Z\"] as const;\n\n/**\n * Check if an array of arrays is potentially a PathArray\n * @param target The incoming value `constructor()` `from()` / `to()`\n * @returns `true` when array is potentially a PathArray\n */\nexport const isPathLike = (\n  value: unknown,\n): value is PathLike => isArray(value) &&\n  value.some(seg => isArray(seg) && supportedPathCommands.includes(seg[0] as never));\n\n/**\n * Check if an array of arrays is a valid PathArray for interpolation\n * @param target The incoming value `from()` / `to()`\n * @returns `true` when array is valid\n */\nexport const isValidPath = (value: unknown): value is MorphPathArray =>\n  isPathLike(value) && value.length > 1 && value.every(isArray) &&\n  value.every(([cmd, ...values]) =>\n    supportedPathCommands.includes(cmd as MorphPathSegment[0]) && (\n      ([\"M\", \"L\"].includes(cmd as MorphPathSegment[0]) && (values as number[]).length === 2 &&\n        values.every(isNumber)) ||\n      (\"C\" === cmd && (values as number[]).length === 6 && values.every(isNumber)) ||\n      (\"Z\" === cmd && (values as number[]).length === 0)\n    )\n  );\n\n/**\n * Validate a PathArray and check if it's compatible with a reference.\n *\n * **NOTE**: Path interpolation only works when both paths have:\n * - Identical segments structure (same number and order of M/L/C/Z)\n * - Corresponding coordinates to interpolate\n * Complex morphs require preprocessing (e.g. KUTE.js, Flubber)\n *\n * @example\n * // simple shapes\n * const linePath1 = [[\"M\", 0, 0],[\"L\", 50, 50]]\n * const linePath2 = [[\"M\",50,50],[\"L\",150,150]]\n * const curvePath1 = [[\"M\", 0, 0],[\"C\",15,15, 35, 35, 50, 50]]\n * const curvePath2 = [[\"M\",50,50],[\"C\",50,50,100,100,150,150]]\n *\n * // closed shapes\n * const closedLinePath1 = [[\"M\", 0, 0],[\"L\", 50, 50],[\"Z\"]]\n * const closedLinePath2 = [[\"M\",50,50],[\"L\",150,150],[\"Z\"]]\n * const closedCurvePath1 = [[\"M\", 0, 0],[\"C\",15,15, 35, 35, 50, 50],[\"Z\"]]\n * const closedCurvePath2 = [[\"M\",50,50],[\"C\",50,50,100,100,150,150],[\"Z\"]]\n *\n * // composit shapes (multi-path)\n * const compositPath1 = [\n *  [\"M\", 0, 0],[\"L\",50,50],\n *  [\"M\",50,50],[\"C\",50,50,100,100,150,150],\n * ]\n * const compositPath2 = [\n *  [\"M\",50,50],[\"L\",150,150],\n *  [\"M\", 0, 0],[\"C\", 15, 15,35,35,50,50],\n * ]\n *\n * @param target The incoming value `from()` / `to()`\n * @param ref The state reference value\n * @returns `true` when arrays are compatible or a reason why not\n */\nexport const validatePath = <T extends MorphPathArray>(\n  propName: string,\n  target: unknown,\n  ref?: T,\n): ValidationResultEntry => {\n  // ref is state[prop] and is already validated on initialization\n  if (!isValidPath(target)) return [false, `Property \"${propName}\" is not a valid PathArray.`];\n\n  if (ref) {\n    if (ref.length !== target.length) {\n      return [\n        false,\n        `Property \"${propName}\" is expecting an array of ${ref.length} path segments, got ${target.length}.`,\n      ];\n    }\n\n    let i = 0;\n    const len = ref.length;\n    while (i < len) {\n      const [pathCommand1, values1] = [\n        ref[i][0],\n        ref[i].slice(1) as LineValues | CubicValues,\n      ];\n      const [pathCommand2, values2] = [\n        target[i][0],\n        target[i].slice(1) as LineValues | CubicValues,\n      ];\n\n      const commandMismatch = pathCommand1 !== pathCommand2;\n      if ((values1.length !== values2.length || commandMismatch)) {\n        return [\n          false,\n          `Property \"${propName}\" mismatch at index ${i}. ` +\n          \"Segments don't match:\" +\n          '\\n > segment: \"[' + pathCommand2 + \", \" + values2 + ']\"' +\n          '\\n > reference: \"[' + pathCommand1 + \", \" + values1 + ']\"',\n        ];\n      }\n      i += 1;\n    }\n  }\n\n  return [true];\n};\n\n/**\n * Config for .use(propName, pathArrayConfig)\n */\nexport const pathArrayConfig = {\n  interpolate: interpolatePath,\n  validate: validatePath,\n};\n","// src/extend/object.ts\nimport type {\n  BaseTweenProps,\n  InterpolatorFunction,\n  ValidationResultEntry,\n} from \"../types.ts\";\nimport { isNumber, isPlainObject } from \"../Util.ts\";\n\n/**\n * Single-level object interpolator\n * **Note**: values must be validated first!\n *\n * Input: { scale: { x: 1, y: 1 } }\n * Output: interpolated flat object with same structure\n * @param target The target value of the object\n * @param start The start value of the object\n * @param end The end value of the object\n * @param value The progress value\n * @returns The interpolated flat object with same structure.\n */\nexport const interpolateObject: InterpolatorFunction<BaseTweenProps> = <\n  T extends BaseTweenProps,\n>(\n  target: T,\n  start: T,\n  end: T,\n  value: number,\n): T => {\n  // Iterate over end keys (we only interpolate what's in end)\n  const keys = Object.keys(end) as (keyof T)[];\n  let i = 0;\n\n  while (i < keys.length) {\n    const key = keys[i++];\n    const endVal = end[key];\n    const startVal = start[key];\n\n    target[key] = (startVal + (endVal - startVal) * value) as T[keyof T];\n  }\n\n  return target;\n};\n\n/**\n * Validate a simple plain object and compare its compatibility with a reference object.\n * @param propName The property name to which this object belongs to\n * @param target The target object itself\n * @param ref A reference object to compare our target to\n * @returns A [boolean, string?] tuple which represents [validity, \"reason why not valid\"]  \n */\nexport const validateObject = (\n  propName: string,\n  target: unknown,\n  ref?: BaseTweenProps,\n): ValidationResultEntry => {\n  if (!isPlainObject(target)) {\n    return [false, `Property \"${propName}\" must be a plain object.`];\n  }\n\n  const keys = Object.keys(target);\n  let i = 0;\n  const iLen = keys.length;\n\n  while (i < iLen) {\n    const key = keys[i++];\n    const value = target[key];\n\n    if (value === null || value === undefined){\n      return [\n        false,\n        `Property \"${key}\" from \"${propName}\" is null/undefined.`,\n      ];\n    }\n\n    // We never want to go down that route\n    // if (isPlainObject(value)) {}\n\n    if (!isNumber(value)) {\n      return [\n        false,\n        (`Property \"${key}\" from \"${propName}\" must be a number.` +\n        `${isPlainObject(value)\n          ? \" Deeper nested objects are not supported.\"\n          : ` Unsupported value: \"${typeof value}\".`}`),\n      ];\n    }\n\n    if (ref) {\n      if (ref[key] === undefined) {\n        return [\n          false,\n          `Property \"${key}\" in \"${propName}\" doesn't exist in the reference object.`,\n        ];\n      }\n    }\n  }\n\n  return [true];\n};\n\n/**\n * Config for .use(propName, objectConfig)\n */\nexport const objectConfig = {\n  interpolate: interpolateObject,\n  validate: validateObject,\n};\n","// src/extend/transform.ts\nimport type {\n  InterpolatorFunction,\n  // Rotate, RotateZ, Scale, Translate,\n  RotateAxisAngle,\n  TransformArray,\n  TransformLike,\n  TransformStep,\n  TransformStepInternal,\n  ValidationResultEntry,\n  Vec3,\n} from \"../types.ts\";\nimport { isArray, isNumber } from \"../Util.ts\";\n\n/**\n * Returns a valid CSS transform string either with transform functions (Eg.: `translate(15px) rotate(25deg)`)\n * or `matrix(...)` / `matrix3d(...)`.\n * When the `toMatrix` parameter is `true` it will create a DOMMatrix instance, apply transform\n * steps and return a `matrix(...)` or `matrix3d(...)` string value.\n * @param steps An array of TransformStep\n * @param toMatrix An optional parameter to modify the function output\n * @returns The valid CSS transform string value\n */\nexport const transformToString = (steps: TransformStep[], toMatrix = false) => {\n  if (toMatrix) {\n    const matrix = new DOMMatrix();\n    const len = steps.length;\n    let i = 0;\n\n    while (i < len) {\n      const step = steps[i++];\n      const fn = step[0];\n\n      switch (fn) {\n        case \"perspective\": {\n          const m2 = new DOMMatrix();\n          m2.m34 = -1 / step[1];\n          matrix.multiplySelf(m2);\n          break;\n        }\n        case \"translate\": {\n          matrix.translateSelf(...(step.slice(1) as Vec3));\n          break;\n        }\n        case \"rotate\": {\n          matrix.rotateSelf(...(step.slice(1) as Vec3));\n          break;\n        }\n        case \"rotateAxisAngle\": {\n          matrix.rotateAxisAngleSelf(...(step.slice(1) as RotateAxisAngle));\n          break;\n        }\n        case \"scale\": {\n          matrix.scaleSelf(...(step.slice(1) as Vec3));\n          break;\n        }\n        case \"skewX\": {\n          matrix.skewXSelf(step[1]);\n          break;\n        }\n        case \"skewY\": {\n          matrix.skewYSelf(step[1]);\n          break;\n        }\n      }\n    }\n\n    return matrix.toString();\n  }\n  // Return CSS transform string\n  const len = steps.length;\n  let i = 0;\n  const functions: string[] = [];\n\n  while (i < len) {\n    const step = steps[i++];\n    const fn = step[0];\n\n    switch (fn) {\n      case \"perspective\": {\n        functions.push(`perspective(${step[1]}px)`);\n        break;\n      }\n      case \"translate\": {\n        const [x, y, z] = step.slice(1) as Vec3;\n        const xStr = `${x}px`;\n        const yStr = y !== undefined ? `${y}px` : \"0px\";\n        const zStr = z !== undefined ? `${z}px` : \"0px\";\n        functions.push(`translate3d(${xStr}, ${yStr}, ${zStr})`);\n        break;\n      }\n      case \"rotate\": {\n        const [rx, ry, rz] = step.slice(1) as Vec3;\n\n        if (typeof rx === \"number\" && ry === undefined && rz === undefined) {\n          functions.push(`rotate(${rx}deg)`);\n        } else {\n          functions.push(`rotateX(${rx}deg)`);\n          // istanbul ignore else @preserve\n          if (ry !== undefined) functions.push(`rotateY(${ry}deg)`);\n          // istanbul ignore else @preserve\n          if (rz !== undefined) functions.push(`rotateZ(${rz}deg)`);\n        }\n        break;\n      }\n      case \"rotateAxisAngle\": {\n        const [ox, oy, oz, angle] = step.slice(1) as RotateAxisAngle;\n        functions.push(`rotate3d(${ox}, ${oy}, ${oz}, ${angle}deg)`);\n        break;\n      }\n      case \"scale\": {\n        const [sx, sy, sz] = step.slice(1) as Vec3;\n        functions.push(`scale(${sx}, ${sy || sx}, ${sz || 1})`);\n        break;\n      }\n      case \"skewX\": {\n        functions.push(`skewX(${step[1]}deg)`);\n        break;\n      }\n      case \"skewY\": {\n        functions.push(`skewY(${step[1]}deg)`);\n        break;\n      }\n    }\n  }\n\n  return functions.join(\" \");\n};\n\n// Helper to lerp two Vec3\n// type Vec3Type = Vec3 | (Rotate | RotateZ | Scale | Translate);\nconst lerpVec3 = <T extends Vec3>(a: T, b: T, t: number): T => {\n  const result = [a[0] + (b[0] - a[0]) * t] as unknown as T;\n  if (a[1] !== undefined && b[1] !== undefined)\n    result.push(a[1] + (b[1] - a[1]) * t);\n  if (a[2] !== undefined && b[2] !== undefined)\n    result.push(a[2] + (b[2] - a[2]) * t);\n\n  return result;\n};\n\n// Helper: lerp rotate angle + optional origin\nconst lerpRotateAngle = (\n  a: RotateAxisAngle,\n  b: RotateAxisAngle,\n  t: number,\n): RotateAxisAngle => [\n  a[0] + (b[0] - a[0]) * t,\n  a[1] + (b[1] - a[1]) * t,\n  a[2] + (b[2] - a[2]) * t,\n  a[3] + (b[3] - a[3]) * t,\n];\n\n/**\n * Interpolator: takes start/end arrays of `TransformStep`s → returns interpolated `TransformStep`s.\n * **Note** - Like `PathArray`, these values are required to have same length and structure.\n * @example\n * const a1: TransformArray = [\n *  [\"translate\", 0, 0],              // [translateX, translateY]\n *  [\"rotate\", 0],                    // [rotateZ]\n *  [\"rotate\", 0, 0],                 // [rotateX, rotateY]\n *  [\"rotateAxisAngle\", 0, 0, 0, 0],  // [originX, originY, originZ, angle]\n *  [\"scale\", 1],                     // [scale]\n *  [\"scale\", 1, 1],                  // [scaleX, scaleY]\n *  [\"perspective\", 800],             // [length]\n * ];\n * const a2: TransformArray = [\n *  [\"translate\", 50, 50],\n *  [\"rotate\", 45],\n *  [\"rotate\", 45, 45],\n *  [\"rotateAxisAngle\", 1, 0, 0, 45],\n *  [\"scale\", 1.5],\n *  [\"scale\", 1.5, 1.2],\n *  [\"perspective\", 400],\n * ];\n *\n * @param target The target `TransformArray`\n * @param start The start `TransformArray`\n * @param end The end `TransformArray`\n * @param t The progress value\n * @returns The interpolated `TransformArray`\n */\nexport const interpolateTransform: InterpolatorFunction<TransformStep[]> = <\n  T extends TransformStepInternal[],\n>(\n  target: T,\n  start: T,\n  end: T,\n  t: number,\n): T => {\n  // const result: TransformStepInternal[] = [];\n  target.length = 0;\n\n  const len = end.length;\n  let i = 0;\n\n  // Apply transforms in order (last wins for same type, but you can make it additive if needed)\n  while (i < len) {\n    const startStep = start[i];\n    const endStep = end[i];\n    i++;\n\n    const fn = endStep[0];\n    const sVals = startStep.slice(1) as Vec3 | RotateAxisAngle;\n    const eVals = endStep.slice(1) as Vec3 | RotateAxisAngle;\n\n    switch (fn) {\n      case \"translate\":\n      case \"rotate\":\n      case \"scale\":\n        target.push([\n          fn,\n          ...lerpVec3(\n            sVals as Vec3,\n            eVals as Vec3,\n            t,\n            // fn === \"scale\",\n          ),\n        ]);\n        break;\n      case \"rotateAxisAngle\":\n        target.push([\n          fn,\n          ...lerpRotateAngle(\n            sVals as RotateAxisAngle,\n            eVals as RotateAxisAngle,\n            t,\n          ),\n        ]);\n        break;\n      case \"skewX\":\n      case \"skewY\":\n      case \"perspective\":\n        target.push([fn, sVals[0] + (eVals[0] - sVals[0]) * t]);\n        break;\n    }\n  }\n\n  return target as T;\n};\n\nconst supportedTransform = [\n  \"perspective\",\n  \"translate\",\n  \"rotate\",\n  \"rotateAxisAngle\",\n  \"scale\",\n  \"skewX\",\n  \"skewY\",\n] as const;\n\n/**\n * Check if an array of arrays is potentially a TransformArray\n * @param target The incoming value `constructor()` `from()` / `to()`\n * @returns `true` when array is potentially a PathArray\n */\nexport const isTransformLike = (value: unknown): value is TransformLike =>\n  isArray(value) &&\n  value.some(\n    (step) => isArray(step) && supportedTransform.includes(step[0] as never),\n  );\n\n/**\n * Check if an array of arrays is a valid TransformArray for interpolation\n * @param target The incoming value `from()` / `to()`\n * @returns `true` when array is valid\n */\nexport const isValidTransformArray = (\n  value: unknown,\n): value is TransformArray =>\n  isTransformLike(value) &&\n  value.every(\n    ([fn, ...values]) =>\n      supportedTransform.includes(fn as TransformStep[0]) &&\n      (([\"translate\", \"rotate\", \"scale\"].includes(fn as TransformStep[0]) &&\n        values.length > 0 &&\n        values.length <= 3 &&\n        values.every(isNumber)) ||\n        (\"rotateAxisAngle\" === fn &&\n          (values as number[]).length === 4 &&\n          values.every(isNumber)) ||\n        ([\"skewX\", \"skewY\", \"perspective\"].includes(fn as string) &&\n          (values as number[]).length === 1 &&\n          isNumber((values as number[])[0]))),\n  );\n\n/**\n * Validator for TransformArray\n * Checks structure + number types + optional param counts\n */\nexport const validateTransform = (\n  propName: string,\n  target: unknown,\n  ref?: TransformArray,\n): ValidationResultEntry => {\n  if (!isValidTransformArray(target)) {\n    return [false, `Property \"${propName}\" must be an array of TransformStep.`];\n  }\n\n  if (ref && ref.length !== target.length) {\n    return [\n      false,\n      `Property \"${propName}\" is expecting an array of ${ref.length} transform steps, got ${target.length}.`,\n    ];\n  }\n  let i = 0;\n  const len = target.length;\n\n  while (i < len) {\n    const step = target[i] as [string, ...Vec3];\n    const refStep = ref?.[i] as [string, ...Vec3] | undefined;\n    const fn = step[0];\n    const values = step.slice(1);\n\n    if (refStep) {\n      if (refStep[0] !== fn || refStep.length !== step.length) {\n        return [\n          false,\n          `Property \"${propName}\" mismatch at index ${i}\":\\n` +\n            `> step: [\"${fn}\", ${values.map((v) => typeof v)}]\\n` +\n            `> reference: [\"${refStep[0]}\", ${refStep\n              .slice(1)\n              .map((v) => typeof v)}]`,\n        ];\n      }\n    }\n    i++;\n  }\n\n  return [true];\n};\n\n/**\n * Config for .use(\"transform\", transformConfig)\n */\nexport const transformConfig = {\n  interpolate: interpolateTransform,\n  validate: validateTransform,\n};\n"],"mappings":"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"}