{"version":3,"file":"tween.min.js","names":[],"sources":["../src/Easing.ts","../src/Util.ts","../src/extend/array.ts","../src/extend/path.ts","../src/extend/object.ts","../src/extend/transform.ts","../src/Now.ts","../src/Runtime.ts","../src/Tween.ts","../src/Timeline.ts","../package.json"],"sourcesContent":["// Easing.ts\nimport type { EasingFunction, EasingFunctionGroup } from \"./types.d.ts\";\n\n/**\n * The Ease class provides a collection of easing functions for use with tween.js.\n */\n\nexport const Easing = Object.freeze({\n  Linear: Object.freeze<EasingFunctionGroup & { None: EasingFunction }>({\n    None(amount: number): number {\n      return amount;\n    },\n    In(amount: number): number {\n      return amount;\n    },\n    Out(amount: number): number {\n      return amount;\n    },\n    InOut(amount: number): number {\n      return amount;\n    },\n  }),\n\n  Quadratic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount;\n      },\n      Out(amount: number): number {\n        return amount * (2 - amount);\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount;\n        }\n\n        return -0.5 * (--amount * (amount - 2) - 1);\n      },\n    },\n  ),\n\n  Cubic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount * amount;\n      },\n      Out(amount: number): number {\n        return --amount * amount * amount + 1;\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount * amount;\n        }\n        return 0.5 * ((amount -= 2) * amount * amount + 2);\n      },\n    },\n  ),\n\n  Quartic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount * amount * amount;\n      },\n      Out(amount: number): number {\n        return 1 - --amount * amount * amount * amount;\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount * amount * amount;\n        }\n\n        return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n      },\n    },\n  ),\n\n  Quintic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount * amount * amount * amount;\n      },\n      Out(amount: number): number {\n        return --amount * amount * amount * amount * amount + 1;\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount * amount * amount * amount;\n        }\n\n        return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\n      },\n    },\n  ),\n\n  Sinusoidal: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return 1 - Math.sin(((1.0 - amount) * Math.PI) / 2);\n      },\n      Out(amount: number): number {\n        return Math.sin((amount * Math.PI) / 2);\n      },\n      InOut(amount: number): number {\n        return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));\n      },\n    },\n  ),\n\n  Exponential: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount === 0 ? 0 : Math.pow(1024, amount - 1);\n      },\n      Out(amount: number): number {\n        return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\n      },\n      InOut(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n\n        if ((amount *= 2) < 1) {\n          return 0.5 * Math.pow(1024, amount - 1);\n        }\n\n        return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\n      },\n    },\n  ),\n\n  Circular: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return 1 - Math.sqrt(1 - amount * amount);\n      },\n      Out(amount: number): number {\n        return Math.sqrt(1 - --amount * amount);\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n        }\n        return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n      },\n    },\n  ),\n\n  Elastic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n\n        return (\n          -Math.pow(2, 10 * (amount - 1)) *\n          Math.sin((amount - 1.1) * 5 * Math.PI)\n        );\n      },\n      Out(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n        return (\n          Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1\n        );\n      },\n      InOut(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n\n        amount *= 2;\n\n        if (amount < 1) {\n          return (\n            -0.5 *\n            Math.pow(2, 10 * (amount - 1)) *\n            Math.sin((amount - 1.1) * 5 * Math.PI)\n          );\n        }\n\n        return (\n          0.5 *\n            Math.pow(2, -10 * (amount - 1)) *\n            Math.sin((amount - 1.1) * 5 * Math.PI) +\n          1\n        );\n      },\n    },\n  ),\n\n  Back: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        const s = 1.70158;\n        return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);\n      },\n      Out(amount: number): number {\n        const s = 1.70158;\n        return amount === 0\n          ? 0\n          : --amount * amount * ((s + 1) * amount + s) + 1;\n      },\n      InOut(amount: number): number {\n        const s = 1.70158 * 1.525;\n        if ((amount *= 2) < 1) {\n          return 0.5 * (amount * amount * ((s + 1) * amount - s));\n        }\n        return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);\n      },\n    },\n  ),\n\n  Bounce: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return 1 - Easing.Bounce.Out(1 - amount);\n      },\n      Out(amount: number): number {\n        if (amount < 1 / 2.75) {\n          return 7.5625 * amount * amount;\n        } else if (amount < 2 / 2.75) {\n          return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n        } else if (amount < 2.5 / 2.75) {\n          return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\n        } else {\n          return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\n        }\n      },\n      InOut(amount: number): number {\n        if (amount < 0.5) {\n          return Easing.Bounce.In(amount * 2) * 0.5;\n        }\n        return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n      },\n    },\n  ),\n\n  pow(power = 4): EasingFunctionGroup {\n    power = power < Number.EPSILON ? Number.EPSILON : power;\n    power = power > 10000 ? 10000 : power;\n    return {\n      In(amount: number): number {\n        return amount ** power;\n      },\n      Out(amount: number): number {\n        return 1 - (1 - amount) ** power;\n      },\n      InOut(amount: number): number {\n        if (amount < 0.5) {\n          return (amount * 2) ** power / 2;\n        }\n        return (1 - (2 - amount * 2) ** power) / 2 + 0.5;\n      },\n    };\n  },\n});\n","import type { DeepObject, DeepPartial, TweenProps } from \"./types.d.ts\";\nimport { type Tween } from \"./Tween.ts\";\nimport { type Timeline } from \"./Timeline.ts\";\n\n// Util.ts\nexport const isString = (value: unknown): value is string =>\n  typeof value === \"string\";\n\nexport const isNumber = (value: unknown): value is number =>\n  typeof value === \"number\";\n\nexport const isArray = (value: unknown): value is Array<unknown> =>\n  Array.isArray(value);\n\nexport const isFunction = (value: unknown): value is () => unknown =>\n  typeof value === \"function\";\n\nexport const isObject = (\n  value: unknown,\n): value is Record<string, never> =>\n  value !== null && value !== undefined && typeof value === \"object\" &&\n  Object.getPrototypeOf(value) === Object.prototype;\n\nexport const isPlainObject = (\n  value: unknown,\n): value is Record<string, never> => isObject(value) && !isArray(value);\n\nexport const isDeepObject = (value: unknown): value is DeepObject =>\n  isPlainObject(value) && Object.values(value).some(isPlainObject);\n\nexport const isServer = typeof window === \"undefined\";\n\nconst instanceMethods = [\n  \"play\",\n  \"label\",\n  \"start\",\n  \"stop\",\n  \"pause\",\n  \"resume\",\n  \"reverse\",\n  \"use\",\n  \"clear\",\n  \"from\",\n  \"to\",\n  \"easing\",\n  \"delay\",\n  \"yoyo\",\n  \"repeat\",\n  \"update\",\n  \"repeatDelay\",\n  \"onStart\",\n  \"onUpdate\",\n  \"onComplete\",\n  \"onStop\",\n  \"onRepeat\",\n];\n\n/**\n * SSR helper to speed up UI frameworks render.\n *\n * Why:\n * - skip validation\n * - skip ministore creation\n * - allow free-form configuration for signal based frameworks\n */\nconst dummyInstance: Record<string, typeof dummyMethod> = {};\n// istanbul ignore next @preserve\n// const dummyMethod = () => dummyInstance;\nfunction dummyMethod(this: typeof dummyInstance) {\n  return this;\n}\n\nfor (let i = 0; i < instanceMethods.length; i++) {\n  dummyInstance[instanceMethods[i]] = dummyMethod;\n}\n\nexport { dummyInstance };\n\n/**\n * Utility to round numbers to a specified number of decimals.\n * @param n Input number value\n * @param round Number of decimals\n * @returns The rounded number\n */\nexport const roundTo = (n: number, round: number) => {\n  const pow = round >= 1 ? 10 ** round : 1;\n  return round > 0 ? Math.round(n * pow) / pow : Math.round(n);\n};\n\nexport const objectHasProp = <T extends object>(obj: T, prop: keyof T) =>\n  Object.prototype.hasOwnProperty.call(obj, prop);\n\nconst isUnsafeKey = (key: string): boolean =>\n  key === \"__proto__\" || key === \"constructor\" || key === \"prototype\";\n\n/**\n * A small utility to deep assign up to one level deep nested objects.\n * This is to prevent breaking reactivity of miniStore.\n *\n * **NOTE** - This doesn't perform ANY check and expects objects values\n * to be validated beforehand.\n * @param target The target to assign values to\n * @param source The source object to assign values from\n */\nexport function deepAssign<T extends TweenProps>(\n  target: T,\n  source: T,\n): void {\n  const keys = Object.keys(source) as (keyof T)[];\n  let i = 0;\n  const len = keys.length;\n\n  while (i < len) {\n    const key = keys[i++];\n    // prevent prototype pollution\n    // istanbul ignore next @preserve\n    if (isUnsafeKey(key as string) || !objectHasProp(source, key)) {\n      continue;\n    }\n    const targetVal = target[key];\n    const sourceVal = source[key];\n\n    if (isArray(sourceVal)) {\n      // Handle arrays (number[], TransformArray, MorphPathArray)\n      const targetArr = targetVal as unknown[];\n      let j = 0;\n      const arLen = sourceVal.length;\n\n      while (j < arLen) {\n        const sourceItem = sourceVal[j];\n\n        if (isArray(sourceItem)) {\n          // Nested array (e.g., TransformStep, MorphPathSegment)\n          // if (!isArray(targetArr[j])) {\n          //   targetArr[j] = [];\n          // }\n          const targetItem = targetArr[j] as unknown[];\n          let k = 0;\n          const itemLen = sourceItem.length;\n          while (k < itemLen) {\n            targetItem[k] = sourceItem[k];\n            k++;\n          }\n        } else {\n          // Primitive in array (e.g., number[] like rgb)\n          targetArr[j] = sourceItem;\n        }\n        j++;\n      }\n    } else if (objectHasProp(target, key) && isObject(sourceVal)) {\n      // Handle nested objects (BaseTweenProps)\n      deepAssign(targetVal as never, sourceVal as never);\n    } else {\n      // Primitive value (number)\n      target[key] = sourceVal;\n    }\n  }\n}\n\n/**\n * Creates a new object with the same structure of a target object / array\n * without its proxy elements / properties, only their values.\n *\n * **NOTE** - The utility is useful to create deep clones as well.\n *\n * @param value An object / array with proxy elements\n * @returns the object / array value without proxy elements\n */\nexport const deproxy = <T>(value: T): T => {\n  if (isArray(value)) {\n    return value.map(deproxy) as T;\n  }\n\n  if (isPlainObject(value)) {\n    const result: Record<string, unknown> = {};\n    for (const key in value) {\n      // istanbul ignore else @preserve\n      if (objectHasProp(value, key)) {\n        result[key] = deproxy(value[key]);\n      }\n    }\n    return result as T;\n  }\n\n  return value;\n};\n\n/**\n * Test values validity or their compatibility with the validated ones\n * in the state. This is something we don't want to do in the runtime\n * update loop.\n * @param this The Tween/Timeline instance\n * @param target The target object to validate\n * @param reference The reference state value\n * @returns void\n */\nexport function validateValues<T extends TweenProps>(\n  this: Timeline | Tween,\n  target: Partial<T> | DeepPartial<T>,\n  reference?: T,\n) {\n  const errors = this.getErrors();\n\n  if (!isPlainObject(target) || Object.keys(target).length === 0) {\n    errors.set(\"init\", \"Initialization value is empty or not an object.\");\n    return;\n  }\n\n  const keys = Object.keys(target);\n\n  // skip if from()/to() was used before one another\n  // we don't want to validate props invalidated!\n  if (reference && keys.some((key) => errors.has(key))) {\n    return;\n  }\n\n  // Validate every value\n  let i = 0;\n  while (i < keys.length) {\n    const key = keys[i++];\n    const refValue = reference?.[key];\n    const value = target[key];\n\n    // everything else is either number or not supported\n    if (isNumber(value)) {\n      // no error there\n      // this.removeError(key);\n      continue; // good value\n    }\n\n    if (value === undefined || value === null) {\n      errors.set(key, `Property \"${key}\" is null/undefined.`);\n      continue;\n    }\n\n    if (reference && refValue === undefined) {\n      errors.set(key, `Property \"${key}\" doesn't exist in state yet.`);\n      continue;\n    }\n\n    // allow validators to override default validation behavior\n    const validator = this.getValidator(key);\n    if (validator) {\n      const [valid, reason] = validator(key, value, refValue as never);\n      if (valid) errors.delete(key);\n      else errors.set(key, reason as string);\n      continue;\n    }\n\n    if (reference && isNumber(refValue)) {\n      // istanbul ignore else @preserve\n      if (!isNumber(value)) {\n        errors.set(key, `Property \"${key}\" is not a number.`);\n      }\n      // only validators can revalidate\n      // this case can never be covered\n      // else this.removeError(key);\n\n      continue;\n    }\n\n    // Any value here is either not valid or not supported yet\n    errors.set(\n      key,\n      `Property \"${key}\" of type \"${\n        isArray(value) ? \"array\" : typeof value\n      }\" is not supported yet.`,\n    );\n  }\n  errors.delete(\"init\");\n}\n","// src/extend/array.ts\nimport { isArray, isNumber } from \"../Util.ts\";\nimport { InterpolatorFunction, ValidationResultEntry } from \"../types.ts\";\n\n/**\n * Interpolates two `Array<number>` values.\n *\n * **NOTE**: Values my be validated first!\n *\n * @param target The target `Array<number>` value of the state object\n * @param start The start `Array<number>` value\n * @param end The end `Array<number>` value\n * @param t The progress value\n * @returns The interpolated `Array<number>` value.\n */\nexport const interpolateArray: InterpolatorFunction<number[]> = <\n  T extends number[],\n>(\n  target: T,\n  start: T,\n  end: T,\n  t: number,\n) => {\n  const len = end.length;\n  let i = 0;\n\n  while (i < len) {\n    target[i] = start[i] + (end[i] - start[i]) * t;\n    i += 1;\n  }\n\n  return target;\n};\n\n/**\n * Check if a value is a valid `Array<number>` for interpolation.\n * @param target The array to check\n * @returns `true` is value is array and all elements are numbers\n */\nexport const isValidArray = <T extends number[]>(\n  target: unknown,\n): target is T => isArray(target) && target.every(isNumber);\n\n/**\n * Check if an `Array<number>` is valid and compatible with a reference.\n *\n * @param target The incoming value `from()` / `to()`\n * @param ref The state reference value\n * @returns [boolean, reason] tuple with validation state as boolean and,\n * if not valid, a reason why it's not valid\n */\nexport const validateArray = <T extends number[]>(\n  propName: string,\n  target: unknown,\n  ref?: T,\n): ValidationResultEntry => {\n  // istanbul ignore if @preserve\n  if (!isArray(target)) {\n    return [false, `Property \"${String(propName)}\" is not Array.`];\n  }\n  // istanbul ignore if @preserve\n  if (!isValidArray(target)) {\n    return [\n      false,\n      `Property \"${String(propName)}\" is not a valid Array<number>.`,\n    ];\n  }\n\n  if (ref && ref.length !== target.length) {\n    return [\n      false,\n      `Property \"${\n        String(propName)\n      }\" is expecting an array of ${ref.length} numbers.`,\n    ];\n  }\n\n  return [true];\n};\n\n/**\n * Config for .use(propName, arrayConfig)\n */\nexport const arrayConfig = {\n  interpolate: interpolateArray,\n  validate: validateArray,\n};\n","// src/extend/path.ts\nimport { isArray, isNumber } from \"../Util.ts\";\n\nimport type {\n  InterpolatorFunction,\n  MorphPathArray,\n  MorphPathSegment,\n  PathLike,\n  ValidationResultEntry,\n} from \"../types.ts\";\n\nimport { roundTo } from \"../Util.ts\";\n\n/**\n * Iterates a `PathArray` value and concatenates the values into a string to return it.\n *\n * **NOTE**: Segment values are rounded to 4 decimals by default.\n * @param path A source PathArray\n * @param round An optional parameter to round segment values to a number of decimals\n * @returns A valid HTML `description` (d) path string value\n */\nexport function pathToString(path: MorphPathArray, round = 4) {\n  const pathLen = path.length;\n  let segment = path[0];\n  let result = \"\";\n  let i = 0;\n  let segLen = 0;\n\n  while (i < pathLen) {\n    segment = path[i++];\n    segLen = segment.length;\n    result += segment[0];\n\n    let j = 1;\n\n    while (j < segLen) {\n      result += roundTo(segment[j++] as number, round);\n      if (j !== segLen) result += \" \";\n    }\n  }\n\n  return result;\n}\n\n/**\n * Interpolate `PathArray` values.\n *\n * **NOTE**: these values must be validated first!\n * @param target - The target PathArray value\n * @param start - A starting PathArray value\n * @param end - An ending PathArray value\n * @param t - The progress value\n * @returns The interpolated PathArray value\n */\nexport const interpolatePath: InterpolatorFunction<MorphPathSegment[]> = <\n  T extends MorphPathSegment[],\n>(\n  target: T,\n  start: T,\n  end: T,\n  t: number,\n): T => {\n  const segCount = end.length;\n  let i = 0;\n\n  while (i < segCount) {\n    const targetSeg = target[i];\n    const startSeg = start[i];\n    const endSeg = end[i];\n\n    if (targetSeg[0] === \"Z\") {\n      i++;\n      continue;\n    } else if (targetSeg[0] === \"C\") {\n      targetSeg[1] = startSeg[1]! + (endSeg[1]! - startSeg[1]!) * t;\n      targetSeg[2] = startSeg[2]! + (endSeg[2]! - startSeg[2]!) * t;\n      targetSeg[3] = startSeg[3]! + (endSeg[3]! - startSeg[3]!) * t;\n      targetSeg[4] = startSeg[4]! + (endSeg[4]! - startSeg[4]!) * t;\n      targetSeg[5] = startSeg[5]! + (endSeg[5]! - startSeg[5]!) * t;\n      targetSeg[6] = startSeg[6]! + (endSeg[6]! - startSeg[6]!) * t;\n    } else { // M / L\n      targetSeg[1] = startSeg[1]! + (endSeg[1]! - startSeg[1]!) * t;\n      targetSeg[2] = startSeg[2]! + (endSeg[2]! - startSeg[2]!) * t;\n    }\n    i++;\n  }\n\n  return target as T;\n};\n\nconst supportedPathCommands = [\"M\", \"L\", \"C\", \"Z\"] as const;\n\n/**\n * Check if an array of arrays is potentially a PathArray\n * @param target The incoming value `constructor()` `from()` / `to()`\n * @returns `true` when array is potentially a PathArray\n */\nexport const isPathLike = (\n  value: unknown,\n): value is PathLike =>\n  isArray(value) &&\n  value.some((seg) =>\n    isArray(seg) && supportedPathCommands.includes(seg[0] as never)\n  );\n\n/**\n * Check if an array of arrays is a valid PathArray for interpolation\n * @param target The incoming value `from()` / `to()`\n * @returns `true` when array is valid\n */\nexport const isValidPath = (value: unknown): value is MorphPathArray =>\n  isPathLike(value) && value.length > 1 && value.every(isArray) &&\n  value.every(([cmd, ...values]) =>\n    supportedPathCommands.includes(cmd as MorphPathSegment[0]) && (\n      ([\"M\", \"L\"].includes(cmd as MorphPathSegment[0]) &&\n        (values as number[]).length === 2 &&\n        values.every(isNumber)) ||\n      (\"C\" === cmd && (values as number[]).length === 6 &&\n        values.every(isNumber)) ||\n      (\"Z\" === cmd && (values as number[]).length === 0)\n    )\n  );\n\n/**\n * Validate a `PathArray` and check if it's compatible with a reference.\n *\n * **NOTE**: Path interpolation only works when both paths have:\n * - Identical segments structure (same number and order of M/L/C/Z path commands)\n * - Corresponding coordinates to interpolate\n * Complex morphs require preprocessing (e.g. KUTE.js, Flubber)\n *\n * @example\n * // simple shapes\n * const linePath1 = [[\"M\", 0, 0],[\"L\", 50, 50]]\n * const linePath2 = [[\"M\",50,50],[\"L\",150,150]]\n * const curvePath1 = [[\"M\", 0, 0],[\"C\",15,15, 35, 35, 50, 50]]\n * const curvePath2 = [[\"M\",50,50],[\"C\",50,50,100,100,150,150]]\n *\n * // closed shapes\n * const closedLinePath1 = [[\"M\", 0, 0],[\"L\", 50, 50],[\"Z\"]]\n * const closedLinePath2 = [[\"M\",50,50],[\"L\",150,150],[\"Z\"]]\n * const closedCurvePath1 = [[\"M\", 0, 0],[\"C\",15,15, 35, 35, 50, 50],[\"Z\"]]\n * const closedCurvePath2 = [[\"M\",50,50],[\"C\",50,50,100,100,150,150],[\"Z\"]]\n *\n * // composit shapes (multi-path)\n * const compositPath1 = [\n *  [\"M\", 0, 0],[\"L\",50,50],\n *  [\"M\",50,50],[\"C\",50,50,100,100,150,150],\n * ]\n * const compositPath2 = [\n *  [\"M\",50,50],[\"L\",150,150],\n *  [\"M\", 0, 0],[\"C\", 15, 15,35,35,50,50],\n * ]\n *\n * @param target The incoming value `from()` / `to()`\n * @param ref The state reference value\n * @returns a tuple with validation result as a `boolean` and,\n * if not valid, a reason why value isn't\n */\nexport const validatePath = <T extends MorphPathArray>(\n  propName: string,\n  target: unknown,\n  ref?: T,\n): ValidationResultEntry => {\n  // ref is state[prop] and is already validated on initialization\n  if (!isValidPath(target)) {\n    return [false, `Property \"${propName}\" is not a valid PathArray.`];\n  }\n\n  if (ref) {\n    if (ref.length !== target.length) {\n      return [\n        false,\n        `Property \"${propName}\" is expecting an array of ${ref.length} path segments, got ${target.length}.`,\n      ];\n    }\n\n    let i = 0;\n    const len = ref.length;\n    while (i < len) {\n      const refSeg = ref[i];\n      const targetSeg = target[i];\n      const refCmd = refSeg[0];\n      const targetCmd = targetSeg[0];\n      const refLen = refSeg.length;\n      const targetLen = targetSeg.length;\n\n      if (refCmd !== targetCmd || refLen !== targetLen) {\n        return [\n          false,\n          `Property \"${propName}\" mismatch at index ${i}. ` +\n          `Segments don't match:\\n` +\n          `> segment: \"[${targetCmd}, ${targetSeg.slice(1)}]\"\\n` +\n          `> reference: \"[${refCmd}, ${refSeg.slice(1)}]\"`,\n        ];\n      }\n      i++;\n    }\n  }\n\n  return [true];\n};\n\n/**\n * Config for .use(propName, pathArrayConfig)\n */\nexport const pathArrayConfig = {\n  interpolate: interpolatePath,\n  validate: validatePath,\n};\n","// src/extend/object.ts\nimport type {\n  BaseTweenProps,\n  InterpolatorFunction,\n  ValidationResultEntry,\n} from \"../types.ts\";\nimport { isNumber, isPlainObject } from \"../Util.ts\";\n\n/**\n * Single-level `Record<string, number>` object interpolate function.\n *\n * **NOTE**: values must be validated first!\n *\n * Input: single-level nested object\n *\n * Output: interpolated flat object with same structure\n *\n * @example\n * const initialValues = { translate : { x: 0, y: 0 } };\n * // we will need to validate the value of `translate`\n *\n * @param target The target value of the state object\n * @param start The start value of the object\n * @param end The end value of the object\n * @param t The progress value\n * @returns The interpolated flat object with same structure.\n */\nexport const interpolateObject: InterpolatorFunction<BaseTweenProps> = <\n  T extends BaseTweenProps,\n>(\n  target: T,\n  start: T,\n  end: T,\n  t: number,\n): T => {\n  // Iterate over end keys (we only interpolate what's in end)\n  const keys = Object.keys(end) as (keyof T)[];\n  let i = 0;\n\n  while (i < keys.length) {\n    const key = keys[i++];\n    const endVal = end[key];\n    const startVal = start[key];\n\n    target[key] = (startVal + (endVal - startVal) * t) as T[keyof T];\n  }\n\n  return target;\n};\n\n/**\n * Validate a plain `Record<string, number>` object and compare its compatibility\n * with a reference object.\n * @param propName The property name to which this object belongs to\n * @param target The target object itself\n * @param ref A reference object to compare our target to\n * @returns A [boolean, string?] tuple which represents [validity, \"reason why not valid\"]\n */\nexport const validateObject = (\n  propName: string,\n  target: unknown,\n  ref?: BaseTweenProps,\n): ValidationResultEntry => {\n  if (!isPlainObject(target)) {\n    return [false, `Property \"${propName}\" must be a plain object.`];\n  }\n\n  const keys = Object.keys(target);\n  let i = 0;\n  const iLen = keys.length;\n\n  while (i < iLen) {\n    const key = keys[i++];\n    const value = target[key];\n\n    if (value === null || value === undefined) {\n      return [\n        false,\n        `Property \"${key}\" from \"${propName}\" is null/undefined.`,\n      ];\n    }\n\n    // We never want to go down that route\n    // if (isPlainObject(value)) {}\n\n    if (!isNumber(value)) {\n      return [\n        false,\n        `Property \"${key}\" from \"${propName}\" must be a number.` +\n        `${\n          isPlainObject(value)\n            ? \" Deeper nested objects are not supported.\"\n            : ` Unsupported value: \"${typeof value}\".`\n        }`,\n      ];\n    }\n\n    if (ref) {\n      if (ref[key] === undefined) {\n        return [\n          false,\n          `Property \"${key}\" in \"${propName}\" doesn't exist in the reference object.`,\n        ];\n      }\n    }\n  }\n\n  return [true];\n};\n\n/**\n * Config for .use(propName, objectConfig)\n */\nexport const objectConfig = {\n  interpolate: interpolateObject,\n  validate: validateObject,\n};\n","// src/extend/transform.ts\nimport type {\n  InterpolatorFunction,\n  TransformArray,\n  TransformLike,\n  TransformStep,\n  TransformStepInternal,\n  ValidationResultEntry,\n  Vec3,\n} from \"../types.ts\";\nimport { isArray, isNumber } from \"../Util.ts\";\n\n/**\n * Returns a valid CSS transform string either with transform functions (Eg.: `translate(15px) rotate(25deg)`)\n * or `matrix(...)` / `matrix3d(...)`.\n * When the `toMatrix` parameter is `true` it will create a DOMMatrix instance, apply transform\n * steps and return a `matrix(...)` or `matrix3d(...)` string value.\n * @param steps An array of TransformStep\n * @param toMatrix An optional parameter to modify the function output\n * @returns The valid CSS transform string value\n */\nexport const transformToString = (steps: TransformStep[], toMatrix = false) => {\n  if (toMatrix) {\n    const matrix = new DOMMatrix();\n    const len = steps.length;\n    let i = 0;\n\n    while (i < len) {\n      const step = steps[i++];\n\n      switch (step[0]) {\n        case \"perspective\": {\n          const m2 = new DOMMatrix();\n          m2.m34 = -1 / step[1];\n          matrix.multiplySelf(m2);\n          break;\n        }\n        case \"translate\": {\n          matrix.translateSelf(step[1], step[2] || 0, step[3] || 0);\n          break;\n        }\n        case \"rotate\": {\n          matrix.rotateSelf(step[1], step[2] || 0, step[3] || 0);\n          break;\n        }\n        case \"rotateAxisAngle\": {\n          matrix.rotateAxisAngleSelf(step[1], step[2], step[3], step[4]);\n          break;\n        }\n        case \"scale\": {\n          matrix.scaleSelf(step[1], step[2] || 1, step[3] || 1);\n          break;\n        }\n        case \"skewX\": {\n          matrix.skewXSelf(step[1]);\n          break;\n        }\n        case \"skewY\": {\n          matrix.skewYSelf(step[1]);\n          break;\n        }\n      }\n    }\n\n    return matrix.toString();\n  }\n  // Return CSS transform string\n  const len = steps.length;\n  let i = 0;\n  let stringOutput = \"\";\n\n  while (i < len) {\n    const step = steps[i++];\n\n    switch (step[0]) {\n      case \"perspective\": {\n        stringOutput += ` perspective(${step[1]}px)`;\n        break;\n      }\n      case \"translate\": {\n        stringOutput += ` translate3d(${step[1]}px, ${step[2] || 0}px, ${\n          step[3] || 0\n        }px)`;\n        break;\n      }\n      case \"rotate\": {\n        const [rx, ry, rz] = step.slice(1) as Vec3;\n\n        if (typeof rx === \"number\" && ry === undefined && rz === undefined) {\n          stringOutput += ` rotate(${step[1]}deg)`;\n        } else {\n          stringOutput += ` rotateX(${step[1]}deg)`;\n          // istanbul ignore else @preserve\n          if (step[2] !== undefined) stringOutput += ` rotateY(${step[2]}deg)`;\n          // istanbul ignore else @preserve\n          if (step[3] !== undefined) stringOutput += ` rotateZ(${step[3]}deg)`;\n        }\n        break;\n      }\n      case \"rotateAxisAngle\": {\n        stringOutput += ` rotate3d(${step[1]}, ${step[2]}, ${step[3]}, ${\n          step[4]\n        }deg)`;\n        break;\n      }\n      case \"scale\": {\n        stringOutput += ` scale(${step[1]}, ${step[2] || step[1]}, ${\n          step[3] || 1\n        })`;\n        break;\n      }\n      case \"skewX\": {\n        stringOutput += ` skewX(${step[1]}deg)`;\n        break;\n      }\n      case \"skewY\": {\n        stringOutput += ` skewY(${step[1]}deg)`;\n        break;\n      }\n    }\n  }\n\n  return stringOutput.slice(1);\n};\n\n/**\n * Convert euler rotation to axis angle.\n * All values are degrees.\n * @param x rotateX value\n * @param y rotateY value\n * @param z rotateZ value\n * @returns The axis angle tuple [vectorX, vectorY, vectorZ, angle]\n */\nexport const eulerToAxisAngle = (\n  x: number,\n  y: number,\n  z: number,\n): [number, number, number, number] => {\n  // Convert to quaternion first\n  const quat = eulerToQuaternion(x, y, z);\n\n  // Then convert quaternion to axis-angle\n  return quaternionToAxisAngle(quat);\n};\n\n/**\n * Convert euler rotation tuple to quaternion.\n * All values are degrees.\n * @param x The rotateX value\n * @param y The rotateY value\n * @param z The rotateZ value\n * @returns The rotation quaternion\n */\nconst eulerToQuaternion = (\n  x: number,\n  y: number,\n  z: number,\n): [number, number, number, number] => {\n  const cx = Math.cos(x / 2);\n  const sx = Math.sin(x / 2);\n  const cy = Math.cos(y / 2);\n  const sy = Math.sin(y / 2);\n  const cz = Math.cos(z / 2);\n  const sz = Math.sin(z / 2);\n\n  return [\n    cx * cy * cz + sx * sy * sz,\n    sx * cy * cz - cx * sy * sz,\n    cx * sy * cz + sx * cy * sz,\n    cx * cy * sz - sx * sy * cz,\n  ];\n};\n\n/**\n * Convert euler rotation tuple to axis angle.\n * All values are degrees.\n * @param q The rotation quaternion\n * @returns The axis angle tuple [vectorX, vectorY, vectorZ, angle]\n */\nconst quaternionToAxisAngle = (\n  q: [number, number, number, number],\n): [number, number, number, number] => {\n  const [w, x, y, z] = q;\n\n  // Normalize\n  const len = Math.sqrt(x * x + y * y + z * z);\n\n  if (len < 0.0001) {\n    // No rotation\n    return [0, 0, 1, 0];\n  }\n\n  const angle = 2 * Math.acos(Math.max(-1, Math.min(1, w)));\n\n  return [x / len, y / len, z / len, angle];\n};\n\n/**\n * Interpolates arrays of `TransformStep`s → returns interpolated `TransformStep`s.\n *\n * **NOTE** - Like `PathArray`, these values are required to have same length,\n * structure and must be validated beforehand.\n * @example\n * const a1: TransformArray = [\n *  [\"translate\", 0, 0],              // [translateX, translateY]\n *  [\"rotate\", 0],                    // [rotateZ]\n *  [\"rotate\", 0, 0],                 // [rotateX, rotateY]\n *  [\"rotateAxisAngle\", 0, 0, 0, 0],  // [originX, originY, originZ, angle]\n *  [\"scale\", 1],                     // [scale]\n *  [\"scale\", 1, 1],                  // [scaleX, scaleY]\n *  [\"perspective\", 800],             // [length]\n * ];\n * const a2: TransformArray = [\n *  [\"translate\", 50, 50],\n *  [\"rotate\", 45],\n *  [\"rotate\", 45, 45],\n *  [\"rotateAxisAngle\", 1, 0, 0, 45],\n *  [\"scale\", 1.5],\n *  [\"scale\", 1.5, 1.2],\n *  [\"perspective\", 400],\n * ];\n *\n * @param target The target `TransformArray` of the state object\n * @param start The start `TransformArray`\n * @param end The end `TransformArray`\n * @param t The progress value\n * @returns The interpolated `TransformArray`\n */\nexport const interpolateTransform: InterpolatorFunction<TransformStep[]> = <\n  T extends TransformStepInternal[],\n>(\n  target: T,\n  start: T,\n  end: T,\n  t: number,\n): T => {\n  const len = end.length;\n  let i = 0;\n\n  while (i < len) {\n    const targetStep = target[i];\n    const startStep = start[i];\n    const endStep = end[i];\n\n    switch (targetStep[0]) {\n      case \"translate\":\n      case \"rotate\":\n      case \"scale\":\n      case \"rotateAxisAngle\":\n        targetStep[1] = startStep[1] + (endStep[1] - startStep[1]) * t;\n\n        typeof endStep[2] === \"number\" &&\n          (targetStep[2] = startStep[2]! + (endStep[2]! - startStep[2]!) * t);\n\n        typeof endStep[3] === \"number\" &&\n          (targetStep[3] = startStep[3]! + (endStep[3]! - startStep[3]!) * t);\n\n        typeof endStep[4] === \"number\" &&\n          (targetStep[4] = startStep[4]! + (endStep[4]! - startStep[4]!) * t);\n\n        break;\n      case \"skewX\":\n      case \"skewY\":\n      case \"perspective\":\n        targetStep[1] = startStep[1] + (endStep[1] - startStep[1]) * t;\n\n        break;\n    }\n    i++;\n  }\n\n  return target as T;\n};\n\nconst supportedTransform = [\n  \"perspective\",\n  \"translate\",\n  \"rotate\",\n  \"rotateAxisAngle\",\n  \"scale\",\n  \"skewX\",\n  \"skewY\",\n] as const;\n\n/**\n * Check if a value is potentially a `TransformArray`.\n * @param target The incoming value `constructor()` `from()` / `to()`\n * @returns `true` when array is potentially a PathArray\n */\nexport const isTransformLike = (value: unknown): value is TransformLike =>\n  isArray(value) &&\n  value.some(\n    (step) => isArray(step) && supportedTransform.includes(step[0] as never),\n  );\n\n/**\n * Check if a value is a valid `TransformArray` for interpolation.\n * @param target The incoming value `from()` / `to()`\n * @returns a tuple with validation result as a `boolean` and,\n * if not valid, a reason why value isn't\n */\nexport const isValidTransformArray = (\n  value: unknown,\n): value is TransformArray =>\n  isTransformLike(value) &&\n  value.every(\n    ([fn, ...values]) =>\n      supportedTransform.includes(fn as TransformStep[0]) &&\n      (([\"translate\", \"rotate\", \"scale\"].includes(fn as TransformStep[0]) &&\n        values.length > 0 &&\n        values.length <= 3 &&\n        values.every(isNumber)) ||\n        (\"rotateAxisAngle\" === fn &&\n          (values as number[]).length === 4 &&\n          values.every(isNumber)) ||\n        ([\"skewX\", \"skewY\", \"perspective\"].includes(fn as string) &&\n          (values as number[]).length === 1 &&\n          isNumber((values as number[])[0]))),\n  );\n\n/**\n * Validator for `TransformArray` that checks\n * structure + parameter counts, and if provided,\n * the compatibility with a reference value.\n */\nexport const validateTransform = (\n  propName: string,\n  target: unknown,\n  ref?: TransformArray,\n): ValidationResultEntry => {\n  if (!isValidTransformArray(target)) {\n    return [false, `Property \"${propName}\" must be an array of TransformStep.`];\n  }\n\n  if (ref) {\n    if (ref.length !== target.length) {\n      return [\n        false,\n        `Property \"${propName}\" is expecting an array of ${ref.length} transform steps, got ${target.length}.`,\n      ];\n    }\n\n    let i = 0;\n    const len = target.length;\n\n    while (i < len) {\n      const step = target[i] as [string, ...Vec3];\n      const refStep = ref[i] as [string, ...Vec3];\n      const fn = step[0];\n      const fnRef = refStep[0];\n\n      // istanbul ignore else @preserve\n      if (refStep) {\n        if (fnRef !== fn || refStep.length !== step.length) {\n          return [\n            false,\n            `Property \"${propName}\" mismatch at index ${i}\":\\n` +\n            `> step: [\"${fn}\", ${step.slice(1)}]\\n` +\n            `> reference: [\"${fnRef}\", ${refStep.slice(1)}]`,\n          ];\n        }\n      }\n      i++;\n    }\n  }\n\n  return [true];\n};\n\n/**\n * Config for .use(\"transform\", transformConfig)\n */\nexport const transformConfig = {\n  interpolate: interpolateTransform,\n  validate: validateTransform,\n};\n","let _nowFunc = () => globalThis.performance.now();\n\nexport const now = (): number => {\n  return _nowFunc();\n};\n\nexport function setNow(nowFunction: typeof _nowFunc) {\n  _nowFunc = nowFunction;\n}\n","// Runtime.ts\nimport type { AnimationItem, TweenProps } from \"./types.d.ts\";\nimport { now } from \"./Now.ts\";\n\n/**\n * The runtime queue\n */\nexport const Queue: AnimationItem[] = new Array(0);\n\nlet rafID = 0;\nlet queueLength = 0;\n\n/**\n * The hot update loop updates all items in the queue,\n * and stops automatically when there are no items left.\n * @param t execution time (performance.now)\n */\nexport function Runtime(t = now()) {\n  let i = 0;\n  // queueLength = Queue.length;\n  while (i < queueLength) {\n    if (Queue[i]?.update(t)) {\n      i += 1;\n    } else {\n      Queue.splice(i, 1);\n      queueLength--;\n    }\n  }\n\n  if (queueLength === 0) {\n    cancelAnimationFrame(rafID);\n    rafID = 0;\n  } else rafID = requestAnimationFrame(Runtime);\n}\n\n/**\n * Add a new item to the update loop.\n * If it's the first item, it will also start the update loop.\n * @param newItem Tween / Timeline\n */\nexport function addToQueue<T extends TweenProps>(\n  newItem: AnimationItem<T>,\n): void {\n  // istanbul ignore else @preserve\n  if (Queue.includes(newItem as AnimationItem<never>)) return;\n  // Queue.push(item);\n  Queue[queueLength++] = newItem as AnimationItem<never>;\n  // istanbul ignore else @preserve\n  if (!rafID) Runtime();\n}\n\n/**\n * Remove item from the update loop.\n * @param newItem Tween / Timeline\n */\nexport function removeFromQueue<T extends TweenProps>(\n  removedItem: AnimationItem<T>,\n): void {\n  const idx = Queue.indexOf(removedItem as AnimationItem<never>);\n  // istanbul ignore else @preserve\n  if (idx > -1) {\n    Queue.splice(idx, 1);\n    queueLength--;\n  }\n}\n","// Tween.ts\nimport type {\n  DeepPartial,\n  EasingFunction,\n  InterpolatorFunction,\n  PropConfig,\n  TweenCallback,\n  TweenProps,\n  TweenRuntime,\n  TweenUpdateCallback,\n  ValidationFunction,\n} from \"./types.d.ts\";\nimport {\n  deepAssign,\n  deproxy,\n  isArray,\n  isObject,\n  validateValues,\n} from \"./Util.ts\";\nimport { addToQueue, removeFromQueue } from \"./Runtime.ts\";\nimport { now } from \"./Now.ts\";\n\n/**\n * Lightweight tween engine for interpolating values over time.\n * Supports numbers and via extensions it enxtends to arrays\n * (e.g. RGB, points), nested objects, and SVG path morphing.\n *\n * @template T - The type of the target object (usually a plain object with numeric properties)\n *\n * @example\n * ```ts\n * const tween = new Tween({ x: 0, opacity: 1 })\n *   .to({ x: 300, opacity: 0 })\n *   .duration(1.5)\n *   .easing(Easing.Elastic.Out)\n *   .start();\n * ```\n *\n * @param initialValues The initial values object\n */\nexport class Tween<T extends TweenProps = TweenProps> {\n  state: T;\n  private _state: T;\n  private _startIsSet = false;\n  private _repeat = 0;\n  private _yoyo = false;\n  private _reversed = false;\n  private _initialRepeat = 0;\n  private _startFired = false;\n  private _propsStart: Partial<T> = {};\n  private _propsEnd: Partial<T> = {};\n  private _isPlaying = false;\n  private _duration = 1000;\n  private _delay = 0;\n  private _pauseStart = 0;\n  private _repeatDelay = 0;\n  private _startTime: number = 0;\n  private _errors = new Map<string | \"init\", string>();\n  private _interpolators = new Map<string | keyof T, InterpolatorFunction>();\n  private _validators = new Map<string | keyof T, ValidationFunction>();\n  private _easing: EasingFunction = (t) => t;\n  private _onUpdate?: TweenUpdateCallback<T>;\n  private _onComplete?: TweenCallback<T>;\n  private _onStart?: TweenCallback<T>;\n  private _onStop?: TweenCallback<T>;\n  private _onPause?: TweenCallback<T>;\n  private _onResume?: TweenCallback<T>;\n  private _onRepeat?: TweenCallback<T>;\n  private _runtime: (TweenRuntime<T>)[] = [];\n  /**\n   * Creates a new Tween instance.\n   * @param initialValues - The initial state of the animated object\n   */\n  constructor(initialValues: T) {\n    // we must initialize state to allow isValidState to work from here\n    this.state = {} as T;\n    validateValues.call(this as unknown as Tween, initialValues);\n    if (this._errors.size) {\n      // we temporarily store initialValues reference here\n      this._state = initialValues;\n    } else {\n      // or set values right away\n      this.state = initialValues;\n      this._state = deproxy(initialValues);\n    }\n\n    return this;\n  }\n\n  // GETTERS FIRST\n  /**\n   * A boolean that returns `true` when tween is playing.\n   */\n  get isPlaying(): boolean {\n    return this._isPlaying;\n  }\n\n  /**\n   * A boolean that returns `true` when tween is paused.\n   */\n  get isPaused(): boolean {\n    return this._pauseStart > 0;\n  }\n\n  /**\n   * A boolean that returns `true` when initial values are valid.\n   */\n  get isValidState(): boolean {\n    return Object.keys(this.state).length > 0;\n  }\n\n  /**\n   * A boolean that returns `true` when all values are valid.\n   */\n  get isValid(): boolean {\n    return this._errors.size === 0;\n  }\n\n  /**\n   * Returns the configured duration in seconds.\n   */\n  getDuration() {\n    return this._duration / 1000;\n  }\n\n  /**\n   * Returns the total duration in seconds. It's calculated as a sum of\n   * the delay, duration multiplied by repeat value, repeat delay multiplied\n   * by repeat value.\n   */\n  get totalDuration() {\n    const repeat = this._initialRepeat;\n    return (\n      this._delay +\n      this._duration * (repeat + 1) +\n      this._repeatDelay * repeat\n    ) / 1000;\n  }\n\n  /**\n   * Returns the validator configured for a given property.\n   */\n  getValidator(propName: string) {\n    return this._validators.get(propName);\n  }\n\n  /**\n   * Returns the errors Map, mainly used by external validators.\n   */\n  getErrors() {\n    return this._errors;\n  }\n\n  /**\n   * Starts the tween (adds it to the global update loop).\n   * Triggers `onStart` if set.\n   * @param time - Optional explicit start time (defaults to `now()`)\n   * @param overrideStart - If true, resets starting values even if already set\n   * @returns this\n   */\n  start(time = now(), overrideStart = false) {\n    if (this._isPlaying) return this;\n    if (this._pauseStart) return this.resume();\n    if (!this.isValid) {\n      this._report();\n      return this;\n    }\n    // micro-optimization - don't reset state if never started\n    if (this._startTime && !overrideStart) this._resetState();\n\n    // istanbul ignore else @preserve\n    if (!this._startIsSet || /* istanbul ignore next */ overrideStart) {\n      this._startIsSet = true;\n\n      this._setProps(\n        this.state,\n        this._propsStart,\n        this._propsEnd,\n        overrideStart,\n      );\n    }\n    this._isPlaying = true;\n    this._startTime = time;\n    this._startTime += this._delay;\n\n    addToQueue(this);\n    return this;\n  }\n\n  /**\n   * Starts the tween from current values.\n   * @param time - Optional explicit start time (defaults to `now()`)\n   * @returns this\n   */\n  startFromLast(time = now()) {\n    return this.start(time, true);\n  }\n\n  /**\n   * Immediately stops the tween and removes it from the update loop.\n   * Triggers `onStop` if set.\n   * @returns this\n   */\n  stop() {\n    if (!this._isPlaying) return this;\n    removeFromQueue(this);\n    this._isPlaying = false;\n    this._repeat = this._initialRepeat;\n    this._reversed = false;\n\n    this._onStop?.(this.state);\n    return this;\n  }\n\n  /**\n   * Reverses playback direction and mirrors current time position.\n   * @returns this\n   */\n  reverse(): this {\n    // istanbul ignore next @preserve\n    if (!this._isPlaying) return this;\n\n    const currentTime = now();\n    const elapsed = currentTime - this._startTime;\n    this._startTime = currentTime - (this._duration - elapsed);\n    this._reversed = !this._reversed;\n\n    // istanbul ignore else @preserve\n    if (this._initialRepeat > 0) {\n      this._repeat = this._initialRepeat - this._repeat;\n    }\n\n    return this;\n  }\n\n  /**\n   * Pause playback and capture the pause time.\n   * @param time - Time of pause\n   * @returns this\n   */\n  pause(time = now()): this {\n    if (!this._isPlaying) return this;\n\n    this._pauseStart = time;\n    this._isPlaying = false;\n    this._onPause?.(this.state);\n\n    return this;\n  }\n\n  /**\n   * Resume playback and reset the pause time.\n   * @param time - Time of pause\n   * @returns this\n   */\n  resume(time = now()): this {\n    if (!this._pauseStart) return this;\n\n    this._startTime += time - this._pauseStart;\n    this._pauseStart = 0;\n    this._isPlaying = true;\n    this._onResume?.(this.state);\n\n    addToQueue(this);\n\n    return this;\n  }\n\n  /**\n   * Sets the starting values for properties.\n   * @param startValues - Partial object with starting values\n   * @returns this\n   */\n  from(startValues: Partial<T> | DeepPartial<T>) {\n    if (!this.isValidState || this.isPlaying) return this;\n\n    this._evaluate(startValues);\n    if (this.isValid) {\n      Object.assign(this._propsStart, startValues);\n      this._startIsSet = false;\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the ending values for properties.\n   * @param endValues - Partial object with target values\n   * @returns this\n   */\n  to(endValues: Partial<T> | DeepPartial<T>) {\n    if (!this.isValidState || this.isPlaying) return this;\n\n    this._evaluate(endValues);\n    if (this.isValid) {\n      this._propsEnd = endValues as T;\n      this._startIsSet = false;\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the duration of the tween in seconds.\n   * Internally it's converted to milliseconds.\n   * @param duration - Time in seconds\n   * @default 1 second\n   * @returns this\n   */\n  duration(seconds = 1) {\n    this._duration = seconds * 1000;\n    return this;\n  }\n\n  /**\n   * Sets the delay in seconds before the tween starts.\n   * Internally it's converted to milliseconds.\n   * @param delay - Time in seconds\n   * @default 0 seconds\n   * @returns this\n   */\n  delay(seconds = 0) {\n    this._delay = seconds * 1000;\n    return this;\n  }\n\n  /**\n   * Sets how many times to repeat.\n   * @param times - How many times to repeat\n   * @default 0 times\n   * @returns this\n   */\n  repeat(times = 0) {\n    this._repeat = times;\n    this._initialRepeat = times;\n    return this;\n  }\n\n  /**\n   * Sets a number of seconds to delay the animation\n   * after each repeat.\n   * @param seconds - How many seconds to delay\n   * @default 0 seconds\n   * @returns this\n   */\n  repeatDelay(seconds = 0) {\n    this._repeatDelay = seconds * 1000;\n    return this;\n  }\n\n  /**\n   * Sets to tween from end to start values.\n   * The easing is also goes backwards.\n   * This requires repeat value of at least 1.\n   * @param yoyo - When `true` values are reversed on every uneven repeat\n   * @default false\n   * @returns this\n   */\n  yoyo(yoyo = false) {\n    this._yoyo = yoyo;\n    return this;\n  }\n\n  /**\n   * Sets the easing function.\n   * @param easing - Function that maps progress [0,1] → eased progress [0,1]\n   * @default linear\n   * @returns this\n   */\n  easing(easing: EasingFunction = (t: number) => t) {\n    this._easing = easing;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.start()` is called.\n   * @param callback - Receives state at start time\n   * @returns this\n   */\n  onStart(callback: TweenCallback<T>) {\n    this._onStart = callback;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired on every frame.\n   * @param callback - Receives current state, elapsed (0–1)\n   * @returns this\n   */\n  onUpdate(callback?: TweenUpdateCallback<T>) {\n    this._onUpdate = callback;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when the tween reaches progress = 1.\n   * @param callback - Receives final state\n   * @returns this\n   */\n  onComplete(callback: TweenCallback<T>) {\n    this._onComplete = callback;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.stop()` is called.\n   * @param callback - Receives state at stop time\n   * @returns this\n   */\n  onStop(callback: TweenCallback<T>) {\n    this._onStop = callback;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `pause()` was called.\n   */\n  onPause(cb: TweenCallback<T>) {\n    this._onPause = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.resume()` was called.\n   */\n  onResume(cb: TweenCallback<T>) {\n    this._onResume = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback that is invoked **every time** one full cycle\n   * (repeat iteration) * of the tween has completed — but **before**\n   * the next repeat begins (if any remain).\n   *\n   * This is different from `onComplete`, which only fires once at the\n   * very end of the entire tween (after all repeats are finished).\n   */\n  onRepeat(cb?: TweenCallback<T>) {\n    this._onRepeat = cb;\n    return this;\n  }\n\n  /**\n   * Manually advances the tween to the given time.\n   * @param time - Current absolute time (performance.now style)\n   *\n   * @returns `true` if the tween is still playing after the update, `false`\n   * otherwise.\n   */\n  update(time = now()) {\n    // istanbul ignore else\n    if (!this._isPlaying) return false;\n\n    // istanbul ignore else\n    if (time < this._startTime) return true;\n\n    // istanbul ignore else\n    if (!this._startFired) {\n      this._onStart?.(this.state);\n      this._startFired = true;\n    }\n\n    const reversed = this._reversed;\n    const state = this.state;\n    const runtime = this._runtime;\n    let progress = (time - this._startTime) / this._duration;\n    // some limits are in good order for reverse\n    // if (progress < 0) progress = 0;\n    if (progress > 1) progress = 1;\n\n    // super cheap yoyo\n    let eased = this._easing(reversed ? 1 - progress : progress);\n    eased = reversed ? 1 - eased : eased;\n\n    const len = runtime.length;\n    let i = 0;\n    while (i < len) {\n      const prop = runtime[i++];\n      const targetObject = prop[0];\n      const property = prop[1];\n      const interpolator = prop[2];\n      const startVal = reversed ? prop[4] : prop[3];\n      const endVal = reversed ? prop[3] : prop[4];\n\n      if (typeof endVal === \"number\") {\n        state[property as keyof T] =\n          ((startVal as number) + (endVal - (startVal as number)) * eased) as T[\n            keyof T\n          ];\n      } else {\n        interpolator(\n          targetObject as never,\n          startVal as never,\n          endVal as never,\n          eased,\n        );\n      }\n    }\n\n    this._onUpdate?.(state, progress);\n\n    // istanbul ignore else\n    if (progress === 1) {\n      if (this._repeat === 0) {\n        this._isPlaying = false;\n        this._repeat = this._initialRepeat;\n        this._reversed = false;\n        this._onComplete?.(state);\n        return false;\n      }\n      // istanbul ignore else @preserve\n      if (this._repeat !== Infinity) this._repeat--;\n      // istanbul ignore else @preserve\n      if (this._yoyo) this._reversed = !reversed;\n      this._startTime = time;\n      this._startTime += this._repeatDelay;\n      this._onRepeat?.(state);\n      return true;\n    }\n\n    return true;\n  }\n\n  /**\n   * Public method to register an extension for a given property.\n   *\n   * **NOTES**\n   * - the extension will validate the initial values once `.use()` is called.\n   * - the `.use()` method must be called before `.to()` / `.from()`.\n   *\n   * @param property The property name\n   * @param extension The extension object\n   * @returns this\n   *\n   * @example\n   *\n   * const tween = new Tween({ myProp: { x: 0, y: 0 } });\n   * tween.use(\"myProp\", objectConfig);\n   */\n  use(property: string, { interpolate, validate }: PropConfig): this {\n    // istanbul ignore else\n    if (interpolate && !this._interpolators.has(property)) {\n      this._interpolators.set(property, interpolate);\n    }\n    if (validate && !this._validators.has(property)) {\n      this._validators.set(property, validate);\n    }\n    this._evaluate();\n    return this;\n  }\n\n  /**\n   * Internal method to reset state to initial values.\n   * @internal\n   */\n  private _resetState() {\n    deepAssign(this.state, this._state);\n  }\n\n  /**\n   * Reset starting values, end values and runtime.\n   */\n  clear() {\n    this._propsStart = {} as T;\n    this._propsEnd = {} as T;\n    this._runtime.length = 0;\n    this._startTime = 0;\n    this._pauseStart = 0;\n    this._repeat = 0;\n    this._initialRepeat = 0;\n    return this;\n  }\n\n  /**\n   * Internal method to handle instrumentation of start and end values for interpolation.\n   * @internal\n   */\n  private _setProps(\n    obj: T,\n    propsStart: Partial<T>,\n    propsEnd: Partial<T>,\n    overrideStartingValues: boolean,\n  ): void {\n    const endKeys = Object.keys(propsEnd) as (keyof T)[];\n    const len = endKeys.length;\n    this._runtime.length = 0;\n    let rtLen = 0;\n    let i = 0;\n\n    while (i < len) {\n      const property = endKeys[i++];\n\n      // Save the starting value, but only once unless override is requested.\n      // istanbul ignore else\n      if (\n        typeof propsStart[property] === \"undefined\" ||\n        overrideStartingValues\n      ) {\n        const objValue = obj[property] as T[keyof T];\n\n        // Update start property value\n        if (isObject(objValue) || isArray(objValue)) {\n          propsStart[property] = deproxy(objValue);\n        } else {\n          // number\n          propsStart[property] = objValue;\n        }\n\n        // Pre-register interpolator\n        const interpolator = this._interpolators.get(property) || null;\n\n        // Store all values needed for interpolation\n        this._runtime[rtLen++] = [\n          objValue,\n          property,\n          interpolator,\n          propsStart[property] as T[keyof T],\n          propsEnd[property] as T[keyof T],\n        ] as TweenRuntime<T>;\n      }\n    }\n  }\n\n  /**\n   * Internal method to handle validation of initial values, start and end values.\n   * @internal\n   */\n  private _evaluate(newObj?: Partial<T> | DeepPartial<T>) {\n    // the reference of the initialization state is stored here\n    // istanbul ignore else @preserve\n    if (!this.isValidState) {\n      const temp = this._state;\n      validateValues.call(this as unknown as Tween, temp);\n      // istanbul ignore else @preserve\n      if (this.isValid) {\n        this.state = temp;\n        this._state = deproxy(temp);\n      }\n    } else if (newObj) {\n      validateValues.call(this as unknown as Tween, newObj, this._state);\n    }\n    return this;\n  }\n\n  /**\n   * Internal method to provide feedback on validation issues.\n   * @internal\n   */\n  private _report() {\n    // istanbul ignore else @preserve\n    if (!this.isValid) {\n      const message = [\n        \"[Tween] failed validation:\",\n        \"- \" + Array.from(this._errors.values()).join(\"\\n- \"),\n      ];\n\n      console.warn(message.join(\"\\n\"));\n    }\n    return this;\n  }\n}\n","// Timeline.ts\nimport type {\n  DeepPartial,\n  InterpolatorFunction,\n  Position,\n  PropConfig,\n  TimelineCallback,\n  TimelineEntry,\n  TimelineEntryConfig,\n  TweenProps,\n  ValidationFunction,\n} from \"./types.d.ts\";\nimport { addToQueue, removeFromQueue } from \"./Runtime.ts\";\nimport {\n  deepAssign,\n  deproxy,\n  isArray,\n  isObject,\n  validateValues,\n} from \"./Util.ts\";\nimport { now } from \"./Now.ts\";\n\n/**\n * Timeline orchestrates multiple tweens with scheduling, overlaps, labels and repeat.\n * Supports numbers and via extensions it enxtends to arrays\n * (e.g. RGB, points), nested objects, and SVG path morphing.\n *\n * @template T - Type of the animated state object\n *\n * @example\n * ```ts\n * const tl = new Timeline({ x: 0, opacity: 0 })\n *   .to({ x: 300, duration: 1.2 })\n *   .to({ opacity: 1, duration: 0.8 }, \"-=0.4\")\n *   .play();\n * ```\n *\n * @param initialValues The initial values object\n */\nexport class Timeline<T extends TweenProps = TweenProps> {\n  public state: T;\n  private _state: T;\n  private _entries: TimelineEntry<T>[] = [];\n  private _labels = new Map<string, number>();\n  private _progress = 0;\n  private _duration = 0;\n  private _yoyo = false;\n  private _reversed = false;\n  private _time = 0;\n  private _pauseTime = 0;\n  private _lastTime = 0;\n  private _isPlaying = false;\n  private _repeat = 0;\n  private _repeatDelay = 0;\n  private _repeatDelayStart = 0;\n  private _initialRepeat = 0;\n  private _errors = new Map<string | \"init\", string>();\n  private _interpolators = new Map<string | keyof T, InterpolatorFunction>();\n  private _validators = new Map<string | keyof T, ValidationFunction>();\n  private _onStart?: TimelineCallback<T>;\n  private _onStop?: TimelineCallback<T>;\n  private _onPause?: TimelineCallback<T>;\n  private _onResume?: TimelineCallback<T>;\n  private _onUpdate?: TimelineCallback<T>;\n  private _onComplete?: TimelineCallback<T>;\n  private _onRepeat?: TimelineCallback<T>;\n\n  /**\n   * Creates a new Timeline instance.\n   * @param initialValues - The initial state of the animated object\n   */\n  constructor(initialValues: T) {\n    // we must initialize state to allow isValidState to work from here\n    this.state = {} as T;\n    validateValues.call(this as Timeline, initialValues);\n    if (this._errors.size) {\n      // we temporarily store initialValues reference here\n      this._state = initialValues;\n    } else {\n      this.state = initialValues;\n      this._state = { ...initialValues };\n    }\n\n    return this;\n  }\n\n  // GETTERS FIRST\n  /**\n   * Returns the current [0-1] progress value.\n   */\n  get progress() {\n    return this._progress;\n  }\n\n  /**\n   * Returns the total duration in seconds.\n   */\n  get duration() {\n    return this._duration / 1000;\n  }\n\n  /**\n   * Returns the total duration in seconds, which is a sum of all entries duration\n   * multiplied by repeat value and repeat delay multiplied by repeat value.\n   */\n  get totalDuration() {\n    const repeat = this._initialRepeat;\n    return (\n      this._duration * (repeat + 1) +\n      this._repeatDelay * repeat\n    ) / 1000;\n  }\n\n  /**\n   * A boolean that returns `true` when timeline is playing.\n   */\n  get isPlaying(): boolean {\n    return this._isPlaying;\n  }\n\n  /**\n   * A boolean that returns `true` when timeline is paused.\n   */\n  get isPaused(): boolean {\n    return !this._isPlaying && this._pauseTime > 0;\n  }\n\n  /**\n   * A boolean that returns `true` when initial values are valid.\n   */\n  get isValidState(): boolean {\n    return Object.keys(this.state).length > 0;\n  }\n\n  /**\n   * A boolean that returns `true` when all values are valid.\n   */\n  get isValid(): boolean {\n    return this._errors.size === 0;\n  }\n\n  /**\n   * Returns the validator configured for a given property.\n   */\n  getValidator(propName: string) {\n    return this._validators.get(propName);\n  }\n\n  /**\n   * Returns the errors Map, mainly used by external validators.\n   */\n  getErrors() {\n    return this._errors;\n  }\n\n  /**\n   * Starts or resumes playback from the beginning (or current time if resumed).\n   * Triggers the `onStart` callback if set.\n   * @param startTime - Optional explicit start timestamp (defaults to now)\n   * @returns this\n   */\n  play(time = now()): this {\n    if (this._pauseTime) return this.resume();\n    if (this._isPlaying) return this;\n    if (!this.isValid) {\n      this._report();\n      return this;\n    }\n    if (this._time) this._resetState();\n    this._isPlaying = true;\n    this._lastTime = time;\n    this._time = 0;\n    this._onStart?.(this.state, 0);\n\n    addToQueue(this);\n    return this;\n  }\n\n  /**\n   * Pauses playback (preserves current time).\n   * Triggers the `onPause` callback if set.\n   * @returns this\n   */\n  pause(time = now()): this {\n    if (!this._isPlaying) return this;\n    this._isPlaying = false;\n    this._pauseTime = time;\n    this._onPause?.(this.state, this.progress);\n    return this;\n  }\n\n  /**\n   * Resumes from paused state (adjusts internal clock).\n   * Triggers the `onResume` callback if set.\n\n   * @param time - Optional current timestamp (defaults to now)\n   * @returns this\n   */\n  resume(time = now()): this {\n    if (this._isPlaying) return this;\n    this._isPlaying = true;\n    const dif = time - this._pauseTime;\n    this._pauseTime = 0;\n    this._lastTime += dif;\n    this._onResume?.(this.state, this.progress);\n\n    addToQueue(this);\n    return this;\n  }\n\n  /**\n   * Reverses playback direction and mirrors current time position.\n   * @returns this\n   */\n  reverse(): this {\n    if (!this._isPlaying) return this;\n\n    this._reversed = !this._reversed;\n    this._time = this._duration - this._time;\n\n    // istanbul ignore else @preserve\n    if (this._initialRepeat > 0) {\n      this._repeat = this._initialRepeat - this._repeat;\n    }\n\n    return this;\n  }\n\n  /**\n   * Jumps to a specific time or label. When playback is reversed\n   * the time is adjusted.\n   * @param pointer - Seconds or label name\n   * @returns this\n   */\n  seek(pointer: number | string): this {\n    const elapsed = this._resolvePosition(pointer);\n\n    this._time = elapsed;\n    return this;\n  }\n\n  /**\n   * Stops playback, resets time to 0, and restores initial state.\n   * Triggers the `onStop` callback if set.\n   * @returns this\n   */\n  stop(): this {\n    if (!this._isPlaying) return this;\n    this._isPlaying = false;\n    this._time = 0;\n    this._pauseTime = 0;\n    this._repeat = this._initialRepeat;\n    this._reversed = false;\n    removeFromQueue(this);\n    this._onStop?.(this.state, this._progress);\n    return this;\n  }\n\n  /**\n   * Sets the number of times the timeline should repeat.\n   * @param count - Number of repeats (0 = once, Infinity = loop forever)\n   * @returns this\n   */\n  repeat(count = 0): this {\n    this._repeat = count;\n    this._initialRepeat = count;\n    return this;\n  }\n\n  /**\n   * Sets a number of seconds to delay the animation\n   * after each repeat.\n   * @param amount - How many seconds to delay\n   * @default 0 seconds\n   * @returns this\n   */\n  repeatDelay(amount = 0) {\n    this._repeatDelay = amount * 1000;\n    return this;\n  }\n\n  /**\n   * Sets to Timeline entries to tween from end to start values.\n   * The easing is also goes backwards.\n   * This requires repeat value of at least 1.\n   * @param yoyo - When `true` values are reversed\n   * @default false\n   * @returns this\n   */\n  yoyo(yoyo = false) {\n    this._yoyo = yoyo;\n    return this;\n  }\n\n  /**\n   * Adds a named time position for use in `.seek(\"label\")`.\n   * @param name - Label identifier\n   * @param position - Time offset or relative position\n   * @returns this\n   */\n  label(name: string, position?: Position): this {\n    this._labels.set(name, this._resolvePosition(position));\n    return this;\n  }\n\n  /**\n   * Adds a new tween entry to the timeline.\n   * @param config - Values to animate + duration, easing, etc.\n   * @param position - Start offset: number, \"+=0.5\", \"-=0.3\", or label name\n   * @returns this (chainable)\n   */\n  to(\n    {\n      duration = 1,\n      easing = (t) => t,\n      ...values\n    }: (Partial<T> | DeepPartial<T>) & TimelineEntryConfig,\n    position: Position = \"+=0\",\n  ): this {\n    if (!this.isValidState || this._isPlaying) return this;\n\n    this._evaluate(values as Partial<T> | DeepPartial<T>);\n    if (this.isValid) {\n      const startTime = this._resolvePosition(position);\n      const to = values as Partial<T> | DeepPartial<T>;\n      const from = {} as Partial<T>;\n      const entryDuration = duration * 1000;\n      const runtime = [] as TimelineEntry<T>[\"runtime\"];\n\n      this._entries.push({\n        from,\n        to,\n        runtime,\n        startTime,\n        duration: entryDuration,\n        easing,\n        isActive: false,\n      });\n\n      const endTime = startTime + entryDuration;\n      this._duration = Math.max(this._duration, endTime);\n    }\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when playback begins.\n   */\n  onStart(cb: TimelineCallback<T>): this {\n    this._onStart = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `pause()` was called.\n   */\n  onPause(cb: TimelineCallback<T>): this {\n    this._onPause = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.play()` / `.resume()` was called.\n   */\n  onResume(cb: TimelineCallback<T>): this {\n    this._onResume = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired on explicit `.stop()`.\n   */\n  onStop(cb: TimelineCallback<T>): this {\n    this._onStop = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired every frame.\n   */\n  onUpdate(cb: TimelineCallback<T>): this {\n    this._onUpdate = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when timeline naturally completes.\n   */\n  onComplete(cb: TimelineCallback<T>): this {\n    this._onComplete = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.play()` / `.resume()` was called.\n   */\n  onRepeat(cb?: TimelineCallback<T>) {\n    this._onRepeat = cb;\n    return this;\n  }\n\n  /**\n   * Public method to register an extension for a given property.\n   *\n   * **NOTES**\n   * - the extension will validate the initial values once `.use()` is called.\n   * - the `.use()` method must be called before `.to()`.\n   *\n   * @param property The property name\n   * @param extension The extension object\n   * @returns this\n   *\n   * @example\n   *\n   * const timeline = new Timeline({ myProp: { x: 0, y: 0 } });\n   * timeline.use(\"myProp\", objectConfig);\n   */\n  use(property: string, { interpolate, validate }: PropConfig): this {\n    // istanbul ignore else\n    if (interpolate && !this._interpolators.has(property)) {\n      this._interpolators.set(property, interpolate);\n    }\n    if (validate && !this._validators.has(property)) {\n      this._validators.set(property, validate);\n    }\n    this._evaluate();\n    return this;\n  }\n\n  /**\n   * Manually advances the timeline to the given time.\n   * @param time - Current absolute time (performance.now style)\n   *\n   * @returns `true` if the timeline is still playing after the update, `false`\n   * otherwise.\n   */\n  update(time = now()) {\n    if (!this._isPlaying) return false;\n\n    if (this._repeatDelayStart) {\n      if (time - this._repeatDelayStart < this._repeatDelay) {\n        this._lastTime = time; // Update lastTime to prevent delta accumulation\n        return true;\n      }\n      // Delay complete\n      this._repeatDelayStart = 0;\n    }\n\n    const delta = time - this._lastTime;\n    const reversed = this._reversed;\n    this._lastTime = time;\n    this._time += delta;\n\n    this._progress = this._time > this._duration\n      ? 1\n      : this._time / this._duration;\n\n    const entries = this._entries;\n    const state = this.state;\n    const entriesLen = entries.length;\n    let i = 0;\n\n    while (i < entriesLen) {\n      const entry = entries[i++];\n\n      // reverse start time\n      const startTime = !reversed\n        ? entry.startTime\n        : this._duration - entry.startTime - entry.duration;\n\n      const localTime = this._time - startTime;\n\n      // Calculate local time within the entry's duration\n      let tweenElapsed = localTime / entry.duration;\n      // some limits are in good order for reverse\n      if (tweenElapsed > 1) tweenElapsed = 1;\n      if (tweenElapsed < 0) tweenElapsed = 0;\n\n      // Only build runtime once on first activation\n      if (!entry.isActive && tweenElapsed > 0 && tweenElapsed < 1) {\n        // istanbul ignore else @preserve\n        if (entry.runtime.length === 0) {\n          this._setEntry(entry, state);\n        }\n        entry.isActive = true;\n      }\n\n      // istanbul ignore else @preserve\n      if (entry.isActive) {\n        // super cheap yoyo\n        let easedValue = entry.easing(\n          reversed ? 1 - tweenElapsed : tweenElapsed,\n        );\n        easedValue = reversed ? 1 - easedValue : easedValue;\n        const runtime = entry.runtime;\n\n        const runtimeLen = runtime.length;\n        let j = 0;\n        while (j < runtimeLen) {\n          const prop = runtime[j++];\n          const targetObject = prop[0];\n          const property = prop[1];\n          const interpolator = prop[2];\n          const startVal = reversed ? prop[4] : prop[3];\n          const endVal = reversed ? prop[3] : prop[4];\n\n          if (typeof endVal === \"number\") {\n            state[property as keyof T] = ((startVal as number) +\n              (endVal - (startVal as number)) * easedValue) as T[keyof T];\n          } else {\n            interpolator(\n              targetObject as never,\n              startVal as never,\n              endVal as never,\n              easedValue,\n            );\n          }\n        }\n        if (tweenElapsed === 1) entry.isActive = false;\n      }\n    }\n\n    this._onUpdate?.(state, this._progress);\n\n    // istanbul ignore else\n    if (this._progress === 1) {\n      // istanbul ignore else\n      if (this._repeat === 0) {\n        this._isPlaying = false;\n        this._repeat = this._initialRepeat;\n        this._reversed = false;\n        this._onComplete?.(state, 1);\n        this._resetState(true);\n\n        return false;\n      }\n\n      // istanbul ignore else @preserve\n      if (this._repeat !== Infinity) this._repeat--;\n      if (this._yoyo) this._reversed = !reversed;\n\n      this._time = 0;\n      this._resetState();\n      this._onRepeat?.(state, this.progress);\n\n      if (this._repeatDelay > 0) this._repeatDelayStart = time;\n\n      return true;\n    }\n\n    return true;\n  }\n\n  /**\n   * Public method to clear all entries, labels and reset timers to zero\n   * or initial value (repeat).\n   */\n  clear() {\n    this._entries.length = 0;\n    this._duration = 0;\n    this._labels.clear();\n    this._time = 0;\n    this._progress = 0;\n    this._pauseTime = 0;\n    this._lastTime = 0;\n    this._repeatDelay = 0;\n    this._repeat = this._initialRepeat;\n    this._repeatDelayStart = 0;\n    this._reversed = false;\n    return this;\n  }\n\n  /**\n   * Internal method to handle instrumentation of start and end values for interpolation\n   * of a tween entry. Only called once per entry on first activation.\n   * @internal\n   */\n  private _setEntry(entry: TimelineEntry<T>, state: T) {\n    const from = entry.from as Partial<T>;\n    const to = entry.to as Partial<T>;\n    const keysTo = Object.keys(to) as (keyof T)[];\n    const keyLen = keysTo.length;\n    entry.runtime = new Array(keyLen);\n    let rtLen = 0;\n    let j = 0;\n\n    while (j < keyLen) {\n      const key = keysTo[j++];\n      const objValue = state[key] as T[keyof T];\n\n      // Capture current state value for 'from'\n      if (isObject(objValue) || isArray(objValue)) {\n        from[key] = deproxy(objValue);\n      } else {\n        // number\n        from[key] = objValue;\n      }\n\n      const interpolator = this._interpolators.get(key) || null;\n\n      // Push tuple\n      entry.runtime[rtLen++] = [\n        objValue,\n        key,\n        interpolator,\n        from[key] as T[keyof T],\n        to[key] as T[keyof T],\n      ] as TimelineEntry<T>[\"runtime\"][0];\n    }\n  }\n\n  /**\n   * Internal method to revert state to initial values and reset entry flags.\n   * @internal\n   */\n  private _resetState(isComplete = false) {\n    let i = 0;\n    const entriesLen = this._entries.length;\n    while (i < entriesLen) {\n      const entry = this._entries[i++];\n      entry.isActive = false;\n    }\n    if (!isComplete) {\n      deepAssign(this.state, this._state);\n    }\n  }\n\n  /**\n   * Internal method to resolve the position relative to the current duration\n   * or a set value in seconds.\n   * @internal\n   */\n  private _resolvePosition(pos?: Position): number {\n    if (typeof pos === \"number\") {\n      return Math.min(this._duration, Math.max(0, pos * 1000));\n    }\n\n    // istanbul ignore else @preserve\n    if (typeof pos === \"string\") {\n      // First try label\n      const labelTime = this._labels.get(pos);\n      if (labelTime !== undefined) return labelTime;\n\n      // Then relative\n      // istanbul ignore else @preserve\n      if (pos.startsWith(\"+=\") || pos.startsWith(\"-=\")) {\n        let offset = parseFloat(pos.slice(2));\n        if (isNaN(offset)) offset = 0;\n        offset *= 1000;\n        return pos.startsWith(\"+=\")\n          ? this._duration + offset\n          : Math.max(0, this._duration - offset);\n      }\n    }\n\n    // Fallback to current duration\n    return this._duration;\n  }\n\n  /**\n   * Internal method to handle validation of initial values and entries values.\n   * @internal\n   */\n  private _evaluate(newObj?: Partial<T> | DeepPartial<T>) {\n    // the reference of the initialization state is stored here\n    // istanbul ignore else @preserve\n    if (!this.isValidState) {\n      const temp = this._state;\n      validateValues.call(this as Timeline, temp);\n      // istanbul ignore else @preserve\n      if (this.isValid) {\n        this.state = temp;\n        this._state = deproxy(temp);\n      }\n    } else if (newObj) {\n      validateValues.call(this as Timeline, newObj, this._state);\n    }\n    return this;\n  }\n\n  /**\n   * Internal method to provide feedback on validation issues.\n   * @internal\n   */\n  private _report() {\n    // istanbul ignore else @preserve\n    if (!this.isValid) {\n      const message = [\n        \"[Timeline] failed validation:\",\n        \"- \" + Array.from(this._errors.values()).join(\"\\n- \"),\n      ].join(\"\\n\");\n\n      console.warn(message);\n    }\n    return this;\n  }\n}\n",""],"mappings":"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"}